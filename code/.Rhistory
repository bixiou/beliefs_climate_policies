}
if ((n.vars>1) & (length(type)>1) & (addmargins==TRUE)) {
warning("WARNING: Only row totals added when more than one table type requested")
#Code lower down selecting type of margin implements this...
}
if ((length(type)>1) & (subtotals==FALSE)) {
warning("WARNING: Can only request supply one table type if requesting suppression of subtotals; suppression of subtotals not executed")
subtotals <- TRUE
}
if ((length(type)==1) & (subtotals==FALSE)) {
choices <- c("frequency", "row.pct", "column.pct", "joint.pct", "total.pct")
tp <- match.arg(type, choices)
if (tp %in% c("row.pct","column.pct","joint.pct")) {
warning("WARNING: subtotals can only be suppressed for tables of type 'frequency' or 'total.pct'")
subtotals<- TRUE
}
}
if ((n.vars > 2) & (n.col.vars>1) & (subtotals==FALSE))
warning("WARNING: suppression of subtotals assumes only 1 col var; table flattened accordingly")
if ( (subtotals==FALSE) & (n.vars>2) )  {
#If subtotals not required AND total table vars > 2
#Reassign all but last col.var as row vars
#[because, for simplicity, Crosstabs assumes removal of subtotals uses tables with only ONE col var]
#N.B. Subtotals only present in tables with > 2 cross-classified vars...
if (length(col.vars)>1) {
row.vars <- c(row.vars,col.vars[-length(col.vars)])
col.vars <- col.vars[length(col.vars)]
n.row.vars <- length(row.vars)
n.col.vars <- 1
}
}
#If dec.places not set by user, set to 2 unlesss only one table of type frequency requested,
#in which case set to 0.  [Leaves user with possibility of having frequency tables with > 0 dp]
if (is.null(dec.places)) {
if ((length(type)==1) & (type[1]=="frequency")) {
dec.places <- 0
} else {
dec.places <-2
}
}
#Take the original input data, whatever form originally supplied in,
#convert into table format using requested row and col vars, and save as 'tbl'
args <- list(...)
if (length(args) > 1) {
if (!all(sapply(args, is.factor)))
stop("If more than one argument is passed then all must be factors")
tbl <- table(...)
}
else {
if (is.factor(...)) {
tbl <- table(...)
}
else if (is.table(...)) {
tbl <- eval(...)
}
else if (is.data.frame(...)) {
#tbl <- table(...)
if (is.null(row.vars) && is.null(col.vars)) {
tbl <- table(...)
}
else {
var.names <- c(row.vars,col.vars)
A <- (...)
tbl <- table(A[var.names])
if(length(var.names==1)) names(dimnames(tbl)) <- var.names
#[table() only autocompletes dimnames for multivariate Crosstabs of dataframes]
}
}
else if (class(...) == "ftable") {
tbl <- eval(...)
if (is.null(row.vars) && is.null(col.vars)) {
row.vars <- names(attr(tbl, "row.vars"))
col.vars <- names(attr(tbl, "col.vars"))
}
tbl <- as.table(tbl)
}
else if (class(...) == "ctab") {
tbl <- eval(...)
if (is.null(row.vars) && is.null(col.vars)) {
row.vars <- tbl$row.vars
col.vars <- tbl$col.vars
}
for (opt in c("dec.places", "type", "style", "percentages",
"addmargins", "subtotals")) if (is.null(get(opt)))
assign(opt, eval(parse(text = paste("tbl$", opt,
sep = ""))))
tbl <- tbl$table
}
else {
stop("first argument must be either factors or a table object")
}
}
#Convert supplied table style into full text string (e.g. "l" becomes "long")
style <- match.arg(style, c("long", "wide"))
#Extract row and col names to be used in creating 'tbl' from supplied input data
nms <- names(dimnames(tbl))
z <- length(nms)
if (!is.null(row.vars) && !is.numeric(row.vars)) {
row.vars <- order(match(nms, row.vars), na.last = NA)
}
if (!is.null(col.vars) && !is.numeric(col.vars)) {
col.vars <- order(match(nms, col.vars), na.last = NA)
}
if (!is.null(row.vars) && is.null(col.vars)) {
col.vars <- (1:z)[-row.vars]
}
if (!is.null(col.vars) && is.null(row.vars)) {
row.vars <- (1:z)[-col.vars]
}
if (is.null(row.vars) && is.null(col.vars)) {
col.vars <- z
row.vars <- (1:z)[-col.vars]
}
#Take the original input data, converted into table format using supplied row and col vars (tbl)
#and create a second version (Crosstab) which stores results as percentages if a percentage table type is requested.
if (type[1] == "frequency")
Crosstab <- tbl
else
Crosstab <- mk.pcnt.tbl(tbl, type[1])
#If multiple table types requested, create and add these to
if (length(type) > 1) {
tbldat <- as.data.frame.table(Crosstab)
z <- length(names(tbldat)) + 1
tbldat[z] <- 1
pcntlab <- type
pcntlab[match("frequency", type)] <- "Count"
pcntlab[match("row.pct", type)] <- "Row %"
pcntlab[match("column.pct", type)] <- "Column %"
pcntlab[match("joint.pct", type)] <- "Joint %"
pcntlab[match("total.pct", type)] <- "Total %"
for (i in 2:length(type)) {
if (type[i] == "frequency")
Crosstab <- tbl
else Crosstab <- mk.pcnt.tbl(tbl, type[i])
Crosstab <- as.data.frame.table(Crosstab)
Crosstab[z] <- i
tbldat <- rbind(tbldat, Crosstab)
}
tbldat[[z]] <- as.factor(tbldat[[z]])
levels(tbldat[[z]]) <- pcntlab
Crosstab <- xtabs(Freq ~ ., data = tbldat)
names(dimnames(Crosstab))[z - 1] <- ""
}
#Add margins if required, adding only those margins appropriate to user request
if (addmargins==TRUE) {
vars <- c(row.vars,col.vars)
if (length(type)==1) {
if (type=="row.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.vars]))
}
else
{ if (type=="column.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[n.row.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.row.vars]))
}
else
{ if (type=="joint.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[(n.row.vars)],vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[(n.row.vars)],vars[n.vars]))
}
else #must be total.pct OR frequency
{ Crosstab <- addmargins(Crosstab)
tbl <- addmargins(tbl)
}
}
}
}
#If more than one table type requested, only adding row totals makes any sense...
if (length(type)>1) {
Crosstab <- addmargins(Crosstab,margin=c(vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.vars]))
}
}
#If subtotals not required, and total vars > 2, create dataframe version of table, with relevent
#subtotal rows / cols dropped [Subtotals only present in tables with > 2 cross-classified vars]
t1 <- NULL
if ( (subtotals==FALSE) & (n.vars>2) )  {
#Create version of Crosstab in ftable format
t1 <- Crosstab
t1 <- ftable(t1,row.vars=row.vars,col.vars=col.vars)
#Convert to a dataframe
t1 <- as.data.frame(format(t1),stringsAsFactors=FALSE)
#Remove backslashes from category names AND colnames
t1 <- apply(t1[,],2, function(x) gsub("\"","",x))
#Remove preceding and trailing spaces from category names to enable accurate capture of 'sum' rows/cols
#[Use of grep might extrac category labels with 'sum' as part of a longer one or two word string...]
t1 <- apply(t1,2,function(x) gsub("[[:space:]]*$","",gsub("^[[:space:]]*","",x)))
#Reshape dataframe to that variable and category labels display as required
#(a) Move col category names down one row; and move col variable name one column to right
t1[2,(n.row.vars+1):ncol(t1)] <- t1[1,(n.row.vars+1):ncol(t1)]
t1[1,] <- ""
t1[1,(n.row.vars+2)] <- t1[2,(n.row.vars+1)]
#(b) Drop the now redundant column separating the row.var labels from the table data + col.var labels
t1 <- t1[,-(n.row.vars+1)]
#In 'lab', assign category labels for each variable to all rows (to allow identification of sub-totals)
lab <- t1[,1:n.row.vars]
for (c in 1:n.row.vars) {
for (r in 2:nrow(lab)) {
if (lab[r,c]=="") lab[r,c] <- lab[r-1,c]
}
}
lab <- (apply(lab[,1:n.row.vars],2,function(x) x=="Sum"))
lab <- apply(lab,1,sum)
#Filter out rows of dataframe containing subtotals
t1 <- t1[((lab==0) | (lab==n.row.vars)),]
#Move the 'Sum' label associated with last row to the first column; in the process
#setting the final row labels associated with other row variables to ""
t1[nrow(t1),1] <- "Sum"
t1[nrow(t1),(2:n.row.vars)] <- ""
#set row and column names to NULL
rownames(t1) <- NULL
colnames(t1) <- NULL
}
#Create output object 'result' [class: Crosstab]
result <- NULL
#(a) record of argument values used to produce tabular output
result$row.vars <- row.vars
result$col.vars <- col.vars
result$dec.places <- dec.places
result$type <- type
result$style <- style
result$percentages <- percentages
result$addmargins <- addmargins
result$subtotals <- subtotals
#(b) tabular output [3 variants]
result$table <- tbl  #Stores original cross-tab frequency counts without margins [class: table]
result$Crosstab <- Crosstab #Stores cross-tab in table format using requested style(frequency/pct) and table margins (on/off)
#[class: table]
result$Crosstab.nosub <- t1  #Crosstab with subtotals suppressed [class: dataframe; or NULL if no subtotals suppressed]
class(result) <- "Crosstab"
#Return 'result' as output of function
result
}
print.Crosstab <- function(x,dec.places=x$dec.places,subtotals=x$subtotals,...) {
row.vars <- x$row.vars
col.vars <- x$col.vars
n.row.vars <- length(row.vars)
n.col.vars <- length(col.vars)
n.vars <- n.row.vars + n.col.vars
if (length(x$type)>1) {
z<-length(names(dimnames(x$Crosstab)))
if (x$style=="long") {
row.vars<-c(row.vars,z)
} else {
col.vars<-c(z,col.vars)
}
}
if (n.vars==1) {
if (length(x$type)==1) {
tmp <- data.frame(round(x$Crosstab,x$dec.places))
colnames(tmp)[2] <- ifelse(x$type=="frequency","Count","%")
print(tmp,row.names=FALSE)
} else {
print(round(x$Crosstab,x$dec.places))
}
}
#If table has only 2 dimensions, or subtotals required for >2 dimensional table,
#print table using ftable() on x$Crosstab
if ((n.vars == 2) | ((subtotals==TRUE) & (n.vars>2))) {
tbl <- ftable(x$Crosstab,row.vars=row.vars,col.vars=col.vars)
if (!all(as.integer(tbl)==as.numeric(tbl))) tbl <- round(tbl,dec.places)
print(tbl,...)
}
#If subtotals NOT required AND > 2 dimensions, print table using write.table() on x$Crosstab.nosub
if ((subtotals==FALSE) & (n.vars>2))  {
t1 <- x$Crosstab.nosub
#Convert numbers to required decimal places, right aligned
width <- max( nchar(t1[1,]), nchar(t1[2,]), 7 )
dec.places <- x$dec.places
number.format <- paste("%",width,".",dec.places,"f",sep="")
t1[3:nrow(t1),((n.row.vars+1):ncol(t1))] <- sprintf(number.format,as.numeric(t1[3:nrow(t1),((n.row.vars+1):ncol(t1))]))
#Adjust column variable label to same width as numbers, left aligned, padding with trailing spaces as required
col.var.format <- paste("%-",width,"s",sep="")
t1[1,(n.row.vars+1):ncol(t1)] <- sprintf(col.var.format,t1[1,(n.row.vars+1):ncol(t1)])
#Adjust column category labels to same width as numbers, right aligned, padding with preceding spaces as required
col.cat.format <- paste("%",width,"s",sep="")
t1[2,(n.row.vars+1):ncol(t1)] <- sprintf(col.cat.format,t1[2,(n.row.vars+1):ncol(t1)])
#Adjust row labels so that each column is of fixed width, using trailing spaces as required
for (i in 1:n.row.vars) {
width <- max(nchar(t1[,i])) + 2
row.lab.format <- paste("%-",width,"s",sep="")
t1[,i] <- sprintf(row.lab.format,t1[,i])
}
write.table(t1,quote=FALSE,col.names=FALSE,row.names=FALSE)
}
}
##### Data #####
## 2.1 Survey "Beliefs climate policies"
decrit(s$sexe)
##### Data #####
## 2.1 Survey "Beliefs climate policies"
decrit(s$sexe, weights = s$weight)
decrit(s$age)
decrit(s$csp)
decrit(s$diplome4)
decrit(s$taille_agglo)
decrit(s$region)
# Table II: Proportion of respondents per target of the payment
decrit(s$cible)
# Table II: Proportion of respondents per target of the payment
decrit(s$cible, weights = s$weight)
# Table II: Proportion of respondents per target of the payment
decrit(s$Cible)
# Table II: Proportion of respondents per target of the payment
decrit(n(s$cible))
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(sa$duree < 7*60, weights = sa$weight)
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(sa$duree < 7*60)
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(s$duree < 7*60, weights = s$weight) # 4%
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(s$duree < 9*60, weights = s$weight) # 4%
# Response time uncorrelated with preferences:
summary(lm(taxe_approbation!='Non' ~ duree, data=s, weights = s$weight))
summary(lm(gagnant_categorie!='Perdant' ~ duree, data=s, weights = s$weight))
summary(lm(gain ~ duree, data=s, weights = s$weight))
summary(lm(taxe_approbation!='Non' ~ duree + I(duree^2), data=s, weights = s$weight)) # .
summary(lm(gagnant_categorie!='Perdant' ~ duree + I(duree^2), data=s, weights = s$weight))
summary(lm(gain ~ duree + I(duree^2), data=s, weights = s$weight))
summary(lm(taxe_approbation!='Non' ~ duree + I(duree^2), data=s, weights = s$weight)) # .
# Bad quality screened out
wtd.mean(sa$test_qualite!='Un peu', weights = sa$weight)
# 2.1.3 Ensuring Data Quality
# Speeder screened out
wtd.mean(sa$duree < 7*60, weights = sa$weight) # 4% in original sample
wtd.mean(s$duree < 7*60, weights = s$weight) # 4%
##### Data #####
## 2.1 Survey "Beliefs climate policies"
# 2.1.1 Table I: Sample Characteristics
decrit(s$sexe)
# Bad quality screened out
wtd.mean(sa$test_qualite!='Un peu', weights = sa$weight)
wtd.mean(s$test_qualite!='Un peu', weights = s$weight) # 0 in final sample
sum(s$taille_menage > 12)
sum(n(s$revenu) > n(s$rev_tot) | n(s$revenu) > 10000 | n(s$rev_tot) > 10000)
sum(n(s$revenu) > n(s$rev_tot) | s$taille_menage < s$nb_adultes | s$taille_menage < s$nb_14_et_plus | n(s$revenu) > 10000 | n(s$rev_tot) > 10000)
sum(s$mauvaise_qualite>0)
decrit(s$mauvaise_qualite) # 250
decrit(s$mauvaise_qualite > 0) # 250
# mauvaise_qualite uncorrelated with preferences
summary(lm(taxe_approbation!='Non' ~ mauvaise_qualite, data=s, weights = s$weight))
summary(lm(gagnant_categorie!='Perdant' ~ mauvaise_qualite, data=s, weights = s$weight))
summary(lm(gain ~ mauvaise_qualite, data=s, weights = s$weight))
s$taille_menage[s$taille_menage > 12] # looks like zipcode
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 - s$hausse_carburants, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 * pmax(2, s$nb_adultes) - s$hausse_carburants, weights = s$weight)
decrit(s$gain, weights = s$weight)
decrit(50 * pmax(2, s$nb_adultes) - s$hausse_chauffage, weights = s$weight)
decrit(110 * pmax(2, s$nb_adultes) - s$hausse_depenses, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 * pmin(2, s$nb_adultes) - s$hausse_carburants, weights = s$weight)
decrit(50 * pmin(2, s$nb_adultes) - s$hausse_chauffage, weights = s$weight)
decrit(110 * pmin(2, s$nb_adultes) - s$hausse_depenses, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage, weights = s$weight)
decrit(s$gain, weights = s$weight)
ggplot(data=s, aes(x=60 * pmin(2, nb_adultes) - hausse_carburants)) + geom_density() + xlim(c(-100, 200))
fit_housing$vrai_gain_chauffage <- 50 * pmin(2, fit_housing$nb_adultes) - fit_housing$obj
fit_housing$estimation_gain_chauffage <- 50 * pmin(2, fit_housing$nb_adultes) - fit_housing$fit
ggplot(data=fit_housing, aes(x=vrai_gain_chauffage)) +
geom_smooth(method = "auto", aes(y=1*(estimation_gain_chauffage > 0))) + ylim(c(0,1)) + xlab("Objective gain without fuel (density in black)") + ylab("P(gain - (hausse_carburants-60) > 0) i.e. proba gain") + xlim(c(-200, 120)) + geom_density(aes(y=..scaled..)) + geom_vline(xintercept=0, col='red')
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage)
decrit(s$gain, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_min, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_max, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_max)
decrit(s$gain > s$simule_gain, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
# Over-estimation of policy costs TODO: correct figures in paper
decrit(s$gain_fuel, weights = s$weight) # mean
decrit(s$gagnant_categorie, weights = s$weight)
decrit(s$gagnant_fuel_categorie, weights = s$weight) # 14% think they win (22% unaffected)
decrit(s$gagnant_chauffage_categorie, weights = s$weight) # 14% think they win (22% unaffected)
233.9086/1505.329
## 3.2 Robustness to assumptions on elasticities
decrit(s$Elasticite_fuel, weights = s$weight) # -0.43 perceived elasticity of French people
decrit(s$Elasticite_fuel_perso, weights = s$weight * s$depense_carburants) #
decrit(s$Elasticite_chauffage_perso, weights = s$weight * s$depense_chauffage) #
# 71% (resp. 80%) think they are strictly more contrained than average for fuel (resp. chauffage)
wtd.(s$Elasticite_fuel_perso > s$Elasticite_fuel, weights=s$weight, na.rm = T)
# 71% (resp. 80%) think they are strictly more contrained than average for fuel (resp. chauffage)
wtd.mean(s$Elasticite_fuel_perso > s$Elasticite_fuel, weights=s$weight, na.rm = T)
wtd.mean(s$Elasticite_chauffage_perso > s$Elasticite_chauffage, weights=s$weight, na.rm = T) # 80%
mar_old <- par()$mar
cex_old <- par()$cex
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
plot(density(objective_gains$transport, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$transport, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# (b) housing
plot(density(objective_gains$housing, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$housing, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# (c) both combined
plot(density(objective_gains$all, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$all, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# Figure 2: CDF of subjective vs. objective gain (including in the inelastic case)
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport_inelastic <- Ecdf(objective_gains_inelastic$transport)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_inelastic$x, cdf_transport_inelastic$y, lwd=2, lty=2, col="blue")
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
objective_gains <- read.csv2("df_objective_gains.csv")
subjective_gains <- read.csv2("df_subjective_gains.csv")
objective_gains_inelastic <- read.csv2("df_objective_gains_inelastic.csv")
objective_gains$transport <- n(objective_gains$gain_net_numeric_uc_fuel)
objective_gains$housing <- n(objective_gains$gain_net_numeric_uc_chauffage)
objective_gains$all <- n(objective_gains$gain_net_numeric_uc_taxe_carbone)
subjective_gains$transport <- n(subjective_gains$subjective_gain_numeric_fuel)
subjective_gains$housing <- n(subjective_gains$subjective_gain_numeric_chauffage)
subjective_gains$all <- n(subjective_gains$subjective_gain_numeric_taxe_carbone)
objective_gains_inelastic$transport <- n(objective_gains_inelastic$gain_net_numeric_uc_fuel)
objective_gains_inelastic$housing <- n(objective_gains_inelastic$gain_net_numeric_uc_chauffage)
objective_gains_inelastic$all <- n(objective_gains_inelastic$gain_net_numeric_uc_taxe_carbone)
objective_gains_inelastic <- read.csv2("df_objective_gains_inelastic.csv")
objective_gains$transport <- n(objective_gains$gain_net_numeric_uc_fuel)
objective_gains$housing <- n(objective_gains$gain_net_numeric_uc_chauffage)
objective_gains$all <- n(objective_gains$gain_net_numeric_uc_taxe_carbone)
subjective_gains$transport <- n(subjective_gains$subjective_gain_numeric_fuel)
subjective_gains$housing <- n(subjective_gains$subjective_gain_numeric_chauffage)
subjective_gains$all <- n(subjective_gains$subjective_gain_numeric_taxe_carbone)
objective_gains_inelastic$transport <- n(objective_gains_inelastic$gain_net_numeric_uc_fuel)
objective_gains_inelastic$housing <- n(objective_gains_inelastic$gain_net_numeric_uc_chauffage)
objective_gains_inelastic$all <- n(objective_gains_inelastic$gain_net_numeric_uc_taxe_carbone)
decrit(subjective_gains$transport)
decrit(subjective_gains$housing)
decrit(subjective_gains$all)
decrit(s$fioul)
decrit(s$gaz)
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
decrit(ss$fioul)
decrit(ss$gaz)
decrit(s$fioul)
names(s)
names(ss)[!(names(ss) %in% names(s))]
which(!(names(ss) %in% names(s)))
write.csv(s, "survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv")
ss <- read.csv("survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv", row.names = 1)
ss <- read.csv("survey_prepared.csv")
ss <- read.csv("survey_prepared.csv", row.names = NULL)
ss <- read.csv("survey_prepared.csv", row.names = TRUE)
ss <- read.csv("survey_prepared.csv")
duplicated(s$id)
which(duplicated(s$id))
write.csv(s, "survey_prepared.csv", row.names = NULL)
write.csv(s, "survey_prepared.csv", row.names = FALSe)
ss <- read.csv("survey_prepared.csv", skip = 1
)
ss <- read.csv("survey_prepared.csv", header = FALSE)
ss <- read.csv("survey_prepared.csv", header = T)
which(duplicated(names(s)))
write.csv(s[-c(1294,1666),], "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
write.csv(s[-c(1294,1666),], "survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv")
write.csv(s[-c(1294,1666),], "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
package("utils")
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
names(s)
names(ss)
names(ss)[!(names(ss) %in% names(s))]
names(ss)[!(names(s) %in% names(ss))]
head(ss$weight)
write.csv2(s, "survey_prepared.csv")
ss <- read.csv2("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
write.csv(s, "survey_prepared.csv", eol="\n\n")
ss <- read.csv("survey_prepared.csv", eol="\n\n")
ss <- read.csv("survey_prepared.csv",)
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
make.names(names(s))
which(make.names(names(s))!=names(s))
ss <- read.csv("survey_prepared.csv", check.names=FALSE)
write.csv(s, "survey_prepared.csv", row.names=FALSE)
ss <- read.csv("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
write.csv(s, "survey_prepared.csv", row.names='n')
write.csv(s, "survey_prepared.csv", row.names=FALSE)
ss <- read.csv("survey_prepared.csv", row.names=NULL)
