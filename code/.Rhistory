if (weights) { mat <- c(sum(data[['weight']][which(n(data[[var]])==-2)])/sum(data[['weight']][!is.missing(n(data[[var]]))]), sum(data[['weight']][which(n(data[[var]])==-1)])/sum(data[['weight']][!is.missing(n(data[[var]]))]), sum(data[['weight']][which(n(data[[var]])==0)])/sum(data[['weight']][!is.missing(n(data[[var]]))]), sum(data[['weight']][which(n(data[[var]])==1)])/sum(data[['weight']][!is.missing(n(data[[var]]))]), sum(data[['weight']][which(n(data[[var]])==2)])/sum(data[['weight']][!is.missing(n(data[[var]]))]),sum(data[['weight']][which(is.missing(data[[var]]) & !is.na(data[[var]]))])/sum(data[['weight']][!is.missing(data[[var]])])) } }
colors <- c(colors, "lightgrey")    }
else {
mat <- c(length(which(n(data[[var]])==-2))/length(which(!is.missing(n(data[[var]])))), length(which(n(data[[var]])==-1))/length(which(!is.missing(n(data[[var]])))), length(which(n(data[[var]])==0))/length(which(!is.missing(n(data[[var]])))),  length(which(n(data[[var]])==1))/length(which(!is.missing(n(data[[var]])))),  length(which(n(data[[var]])==2))/length(which(!is.missing(n(data[[var]])))))
if (weights) { mat <- c(sum(data[['weight']][which(n(data[[var]])==-2)])/sum(data[['weight']][!is.missing(n(data[[var]]))]), sum(data[['weight']][which(n(data[[var]])==-1)])/sum(data[['weight']][!is.missing(n(data[[var]]))]), sum(data[['weight']][which(n(data[[var]])==0)])/sum(data[['weight']][!is.missing(n(data[[var]]))]), sum(data[['weight']][which(n(data[[var]])==1)])/sum(data[['weight']][!is.missing(n(data[[var]]))]), sum(data[['weight']][which(n(data[[var]])==2)])/sum(data[['weight']][!is.missing(n(data[[var]]))])) } }
matrice <- c(matrice, mat) }
matrice <- matrix(c(matrice), ncol=length(vars))
return(matrice)
# return(as.data.frame(matrice))
}
data1 <- function(vars, data=m, weights=T) {
res <- c()
for (var in vars) {
if (weights) { res <- c(res, sum(data[['weight']][which(data[[var]]==TRUE)])/sum(data[['weight']][which(data[[var]]==TRUE | data[[var]]==FALSE)])) }
else { res <- c(res, length(which(data[[var]]==T)))/length(which(data[[var]]==T | data[[var]]==FALSE)) }
}
return( matrix(res, ncol=length(vars)) )
}
color5 <- c(rainbow(4, end=4/15)[1:3], "#00FF00", "#228B22") # the last two are: green, forestgreen
# accord5 <- c("Pas du tout d'accord", "Pas vraiment d'accord", "Indifférent-e", "Assez d'accord", "Tout à fait d'accord")
oui_non5 <- c("Non, pas du tout", "Non, pas vraiment", "Indifférent-e/NSP", "Oui, plutôt", "Oui, tout à fait")
yes_no5 <- c("Not at all", "Not really", "Indifferent/PNR", "Rather yes", "Yes, completely")
# agree5 <- c("Strongly disagree", "Disagree", "Indifferent", "Agree", "Strongly agree")
# evol5 <- c("Baisser fortement", "Baisser légèrement", "Maintenir au niveau", "Augmenter légèrement", "Augmenter fortement")
# evolve5 <- c("Strongly decrease", "Slightly decrease", "Maintain", "Slightly increase", "Strongly increase")
barres <- function(data, file, title="", labels, color, hover=legend, nsp=TRUE, sort=TRUE, legend=hover, showLegend=T, margin_r=0, margin_l=NA, online=FALSE) {
margin_t <- 0
if (title!="") { margin_t <- 100 }
if (grepl("<br>", title)) { margin_t <- 150 }
legendSize <- 10
legendY <- 1.1
legendX <- 0.2
# legendFont <- 'Open Sans'
if (is.na(margin_l)) { margin_l <- 4.7*max(nchar(labels)) }
if (max(nchar(labels)) > 25) { legendSize <- 9 }
# if (max(nchar(labels)) > 50) { legendSize <- 8 }
# if (max(nchar(labels)) > 60) { legendSize <- 7 }
if (max(nchar(labels)) > 50) { # 70
legendSize <- 11
legendY = 1.2
legendX=1
margin_t = 170
}
if (!showLegend) { margin_t <- margin_t - 70}
if (sort) {
agree <- c()
if (nrow(data)==5 | nrow(data)==6) { for (i in 1:length(labels)) { agree <- c(agree, data[4, i] + data[5, i]) } }
else if (nrow(data)==7) { for (i in 1:length(labels)) { agree <- c(agree, data[6, i] + data[7, i]) } }
else { for (i in 1:length(labels)) { agree <- c(agree, data[1, i]) } }
labels <- labels[order(agree)]
data <- matrix(data[, order(agree)], nrow=nrow(data))
}
if (nrow(data)==1 & sort) {
hover <- hover[order(agree)]
for (i in 1:length(hover)) { hover[i] <- paste(hover[i], "<br>Choisi dans ", round(100*data[1, i]), "% des réponses", sep="")}
hovers <- matrix(hover, nrow=length(hover))
}
else {
hovers <- c()
if (nsp) {
for (i in 1:(length(hover)-1)) {
for (j in 1:length(labels)) {
hovers <- c(hovers, paste(hover[i], '<br>', round(100*data[i, j]/(1+data[length(hover), j])), '% des réponses<br>', round(100*data[i, j]), '% des réponses exprimées') )
}
}
for (j in 1:length(labels)) {
hovers <- c(hovers, paste(hover[length(hover)], '<br>', round(100*data[length(hover), j]/(1+data[length(hover), j])), '% des réponses<br>') )
}
}
else {
if (is.element(hover[length(hover)],c("PNR", "NSP"))) hover <- hover[1:(length(hover)-1)]
if (is.element(legend[length(legend)],c("PNR", "NSP"))) legend <- legend[1:(length(legend)-1)]
for (i in 1:length(hover)) {
for (j in 1:length(labels)) {
hovers <- c(hovers, paste(hover[i], '<br>', round(100*data[i, j]), '% des réponses exprimées<br>') )
}
}
}
hovers <- matrix(hovers, ncol=length(hover))
}
bars <- plot_ly(x = data[1,], y = labels, type = 'bar', orientation = 'h', text = hovers[,1], # sort=FALSE,
hoverinfo = 'text', name=legend[1], marker = list(color = color[1], line = list(color = 'white', width = 0))) %>%
layout(xaxis = list(title = "",
showgrid = T,
showline = FALSE,
showticklabels = T,
gridcolor = toRGB("gray70"), # + noir, + proche de 0
gridwidth = 1,
griddash = "dot",
autotick = FALSE,
ticks = "outside",
tick0 = 0,
dtick = 0.1,
ticklen = 5,
tickwidth = 1,
tickcolor = toRGB("gray70"),
zeroline = T,
domain = c(0.15, 1)
),
yaxis = list(title = "",
showgrid = FALSE,
showline = FALSE,
showticklabels = FALSE,
categoryorder = "trace",
zeroline = FALSE),
hovermode = 'closest',
barmode = 'stack',
title = title,
titlefont = list(color='black'),
font = list(color='black'),
# paper_bgcolor = 'rgb(248, 248, 255)', plot_bgcolor = 'rgb(248, 248, 255)',
margin = list(l = margin_l, r = margin_r, t = margin_t, b = 20),
# margin = list(b = 20, t = margin_t),
legend = list(orientation='h', y=legendY, x=legendX, traceorder='normal', font=list(size=legendSize, color='black')), # family='Balto',  , family=legendFont
showlegend = showLegend) %>%
# labeling the y-axis
add_annotations(xref = 'paper', yref = 'y', x = 0.14, y = labels,
xanchor = 'right',
text = labels,
font = list(family = 'Arial', size = 14, color = 'black'),
showarrow = FALSE, align = 'right') # %>%
print(nrow(data))
print(nrow(hovers))
print(ncol(hovers))
if (nrow(data)>1) { for (i in 2:nrow(data)) {
bars <- add_trace(bars, evaluate=TRUE, x = data[i,], name=legend[i], text = hovers[,i], hoverinfo = 'text', marker = list(color = color[i]))
} }
# labeling the first Likert scale (on the top)
# add_annotations(xref = 'x', yref = 'paper',
#                 x = c(10, 90, 110),
#                 y = 1.05,
#                 text = c("Oui", "Non", "NSP"),
#                 font = list(family = 'Arial', size = 16, color = 'black'),
#                 showarrow = FALSE) # %>%
# labeling the percentages of each bar (x_axis)
# add_annotations(xref = 'x', yref = 'y',
#                 x = o / 2, y = labels,
#                 text = paste(data[,"oui"], '%'),
#                 font = list(family = 'Arial', size = 14, color = 'white'),
#                 showarrow = FALSE) %>%
# add_annotations(xref = 'x', yref = 'y',
#                 x = o + n / 2, y = labels,
#                 text = paste(data[,"non"], '%'),
#                 font = list(family = 'Arial', size = 14, color = 'white'),
#                 showarrow = FALSE) %>%
# add_annotations(xref = 'x', yref = 'y',
#                 x = o + n + nsp / 2, y = labels,
#                 text = paste(data[,"nsp"], '%'),
#                 font = list(family = 'Arial', size = 14, color = 'white'),
#                 showarrow = FALSE) %>%
if (online) { api_create(bars, filename=file, sharing="public") }
return(bars)
}
CImedian <- function(vec) { # 95% confidence interval
res <- tryCatch(unlist(ci.median(vec[!is.na(vec) & vec!=-1])), error=function(e) {print('NA')})
return(paste(res[paste('ci.lower')], res[paste('ci.median')], res[paste('ci.upper')], length(which(!is.na(vec) & vec!=-1)))) }
# from http://pcwww.liv.ac.uk/~william/R/crosstab.r http://rstudio-pubs-static.s3.amazonaws.com/6975_c4943349b6174f448104a5513fed59a9.html
crosstab <- function (..., dec.places = NULL, type = NULL, style = "wide", row.vars = NULL, col.vars = NULL, percentages = TRUE,  addmargins = TRUE, subtotals=TRUE) {
#Declare function used to convert frequency counts into relevant type of proportion or percentage
mk.pcnt.tbl <- function(tbl, type) {
a <- length(row.vars)
b <- length(col.vars)
mrgn <- switch(type, column.pct = c(row.vars[-a], col.vars),
row.pct = c(row.vars, col.vars[-b]),
joint.pct = c(row.vars[-a], col.vars[-b]),
total.pct = NULL)
tbl <- prop.table(tbl, mrgn)
if (percentages) {
tbl <- tbl * 100
}
tbl
}
#Find no. of vars (all; row; col) for use in subsequent code
n.row.vars <- length(row.vars)
n.col.vars <- length(col.vars)
n.vars <- n.row.vars + n.col.vars
#Check to make sure all user-supplied arguments have valid values
stopifnot(as.integer(dec.places) == dec.places, dec.places > -1)
#type: see next section of code
stopifnot(is.character(style))
stopifnot(is.logical(percentages))
stopifnot(is.logical(addmargins))
stopifnot(is.logical(subtotals))
stopifnot(n.vars>=1)
#Convert supplied table type(s) into full text string (e.g. "f" becomes "frequency")
#If invalid type supplied, failed match gives user automatic error message
types <- NULL
choices <- c("frequency", "row.pct", "column.pct", "joint.pct", "total.pct")
for (tp in type) types <- c(types, match.arg(tp, choices))
type <- types
#If no type supplied, default to 'frequency + total' for univariate tables and to
#'frequency' for multi-dimenstional tables
#For univariate table....
if (n.vars == 1) {
if (is.null(type)) {
# default = freq count + total.pct
type <- c("frequency", "total.pct")
#row.vars <- 1
} else {
#and any requests for row / col / joint.pct must be changed into requests for 'total.pct'
type <- ifelse(type == "frequency", "frequency", "total.pct")
}
#For multivariate tables...
} else if (is.null(type)) {
# default = frequency count
type <- "frequency"
}
#Check for integrity of requested analysis and adjust values of function arguments as required
if ((addmargins==FALSE) & (subtotals==FALSE)) {
warning("WARNING: Request to suppress subtotals (subtotals=FALSE) ignored because no margins requested (addmargins=FALSE)")
subtotals <- TRUE
}
if ((n.vars>1) & (length(type)>1) & (addmargins==TRUE)) {
warning("WARNING: Only row totals added when more than one table type requested")
#Code lower down selecting type of margin implements this...
}
if ((length(type)>1) & (subtotals==FALSE)) {
warning("WARNING: Can only request supply one table type if requesting suppression of subtotals; suppression of subtotals not executed")
subtotals <- TRUE
}
if ((length(type)==1) & (subtotals==FALSE)) {
choices <- c("frequency", "row.pct", "column.pct", "joint.pct", "total.pct")
tp <- match.arg(type, choices)
if (tp %in% c("row.pct","column.pct","joint.pct")) {
warning("WARNING: subtotals can only be suppressed for tables of type 'frequency' or 'total.pct'")
subtotals<- TRUE
}
}
if ((n.vars > 2) & (n.col.vars>1) & (subtotals==FALSE))
warning("WARNING: suppression of subtotals assumes only 1 col var; table flattened accordingly")
if ( (subtotals==FALSE) & (n.vars>2) )  {
#If subtotals not required AND total table vars > 2
#Reassign all but last col.var as row vars
#[because, for simplicity, crosstabs assumes removal of subtotals uses tables with only ONE col var]
#N.B. Subtotals only present in tables with > 2 cross-classified vars...
if (length(col.vars)>1) {
row.vars <- c(row.vars,col.vars[-length(col.vars)])
col.vars <- col.vars[length(col.vars)]
n.row.vars <- length(row.vars)
n.col.vars <- 1
}
}
#If dec.places not set by user, set to 2 unlesss only one table of type frequency requested,
#in which case set to 0.  [Leaves user with possibility of having frequency tables with > 0 dp]
if (is.null(dec.places)) {
if ((length(type)==1) & (type[1]=="frequency")) {
dec.places <- 0
} else {
dec.places <-2
}
}
#Take the original input data, whatever form originally supplied in,
#convert into table format using requested row and col vars, and save as 'tbl'
args <- list(...)
if (length(args) > 1) {
if (!all(sapply(args, is.factor)))
stop("If more than one argument is passed then all must be factors")
tbl <- table(...)
}
else {
if (is.factor(...)) {
tbl <- table(...)
}
else if (is.table(...)) {
tbl <- eval(...)
}
else if (is.data.frame(...)) {
#tbl <- table(...)
if (is.null(row.vars) && is.null(col.vars)) {
tbl <- table(...)
}
else {
var.names <- c(row.vars,col.vars)
A <- (...)
tbl <- table(A[var.names])
if(length(var.names==1)) names(dimnames(tbl)) <- var.names
#[table() only autocompletes dimnames for multivariate crosstabs of dataframes]
}
}
else if (class(...) == "ftable") {
tbl <- eval(...)
if (is.null(row.vars) && is.null(col.vars)) {
row.vars <- names(attr(tbl, "row.vars"))
col.vars <- names(attr(tbl, "col.vars"))
}
tbl <- as.table(tbl)
}
else if (class(...) == "ctab") {
tbl <- eval(...)
if (is.null(row.vars) && is.null(col.vars)) {
row.vars <- tbl$row.vars
col.vars <- tbl$col.vars
}
for (opt in c("dec.places", "type", "style", "percentages",
"addmargins", "subtotals")) if (is.null(get(opt)))
assign(opt, eval(parse(text = paste("tbl$", opt,
sep = ""))))
tbl <- tbl$table
}
else {
stop("first argument must be either factors or a table object")
}
}
#Convert supplied table style into full text string (e.g. "l" becomes "long")
style <- match.arg(style, c("long", "wide"))
#Extract row and col names to be used in creating 'tbl' from supplied input data
nms <- names(dimnames(tbl))
z <- length(nms)
if (!is.null(row.vars) && !is.numeric(row.vars)) {
row.vars <- order(match(nms, row.vars), na.last = NA)
}
if (!is.null(col.vars) && !is.numeric(col.vars)) {
col.vars <- order(match(nms, col.vars), na.last = NA)
}
if (!is.null(row.vars) && is.null(col.vars)) {
col.vars <- (1:z)[-row.vars]
}
if (!is.null(col.vars) && is.null(row.vars)) {
row.vars <- (1:z)[-col.vars]
}
if (is.null(row.vars) && is.null(col.vars)) {
col.vars <- z
row.vars <- (1:z)[-col.vars]
}
#Take the original input data, converted into table format using supplied row and col vars (tbl)
#and create a second version (crosstab) which stores results as percentages if a percentage table type is requested.
if (type[1] == "frequency")
crosstab <- tbl
else
crosstab <- mk.pcnt.tbl(tbl, type[1])
#If multiple table types requested, create and add these to
if (length(type) > 1) {
tbldat <- as.data.frame.table(crosstab)
z <- length(names(tbldat)) + 1
tbldat[z] <- 1
pcntlab <- type
pcntlab[match("frequency", type)] <- "Count"
pcntlab[match("row.pct", type)] <- "Row %"
pcntlab[match("column.pct", type)] <- "Column %"
pcntlab[match("joint.pct", type)] <- "Joint %"
pcntlab[match("total.pct", type)] <- "Total %"
for (i in 2:length(type)) {
if (type[i] == "frequency")
crosstab <- tbl
else crosstab <- mk.pcnt.tbl(tbl, type[i])
crosstab <- as.data.frame.table(crosstab)
crosstab[z] <- i
tbldat <- rbind(tbldat, crosstab)
}
tbldat[[z]] <- as.factor(tbldat[[z]])
levels(tbldat[[z]]) <- pcntlab
crosstab <- xtabs(Freq ~ ., data = tbldat)
names(dimnames(crosstab))[z - 1] <- ""
}
#Add margins if required, adding only those margins appropriate to user request
if (addmargins==TRUE) {
vars <- c(row.vars,col.vars)
if (length(type)==1) {
if (type=="row.pct")
{ crosstab <- addmargins(crosstab,margin=c(vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.vars]))
}
else
{ if (type=="column.pct")
{ crosstab <- addmargins(crosstab,margin=c(vars[n.row.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.row.vars]))
}
else
{ if (type=="joint.pct")
{ crosstab <- addmargins(crosstab,margin=c(vars[(n.row.vars)],vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[(n.row.vars)],vars[n.vars]))
}
else #must be total.pct OR frequency
{ crosstab <- addmargins(crosstab)
tbl <- addmargins(tbl)
}
}
}
}
#If more than one table type requested, only adding row totals makes any sense...
if (length(type)>1) {
crosstab <- addmargins(crosstab,margin=c(vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.vars]))
}
}
#If subtotals not required, and total vars > 2, create dataframe version of table, with relevent
#subtotal rows / cols dropped [Subtotals only present in tables with > 2 cross-classified vars]
t1 <- NULL
if ( (subtotals==FALSE) & (n.vars>2) )  {
#Create version of crosstab in ftable format
t1 <- crosstab
t1 <- ftable(t1,row.vars=row.vars,col.vars=col.vars)
#Convert to a dataframe
t1 <- as.data.frame(format(t1),stringsAsFactors=FALSE)
#Remove backslashes from category names AND colnames
t1 <- apply(t1[,],2, function(x) gsub("\"","",x))
#Remove preceding and trailing spaces from category names to enable accurate capture of 'sum' rows/cols
#[Use of grep might extrac category labels with 'sum' as part of a longer one or two word string...]
t1 <- apply(t1,2,function(x) gsub("[[:space:]]*$","",gsub("^[[:space:]]*","",x)))
#Reshape dataframe to that variable and category labels display as required
#(a) Move col category names down one row; and move col variable name one column to right
t1[2,(n.row.vars+1):ncol(t1)] <- t1[1,(n.row.vars+1):ncol(t1)]
t1[1,] <- ""
t1[1,(n.row.vars+2)] <- t1[2,(n.row.vars+1)]
#(b) Drop the now redundant column separating the row.var labels from the table data + col.var labels
t1 <- t1[,-(n.row.vars+1)]
#In 'lab', assign category labels for each variable to all rows (to allow identification of sub-totals)
lab <- t1[,1:n.row.vars]
for (c in 1:n.row.vars) {
for (r in 2:nrow(lab)) {
if (lab[r,c]=="") lab[r,c] <- lab[r-1,c]
}
}
lab <- (apply(lab[,1:n.row.vars],2,function(x) x=="Sum"))
lab <- apply(lab,1,sum)
#Filter out rows of dataframe containing subtotals
t1 <- t1[((lab==0) | (lab==n.row.vars)),]
#Move the 'Sum' label associated with last row to the first column; in the process
#setting the final row labels associated with other row variables to ""
t1[nrow(t1),1] <- "Sum"
t1[nrow(t1),(2:n.row.vars)] <- ""
#set row and column names to NULL
rownames(t1) <- NULL
colnames(t1) <- NULL
}
#Create output object 'result' [class: crosstab]
result <- NULL
#(a) record of argument values used to produce tabular output
result$row.vars <- row.vars
result$col.vars <- col.vars
result$dec.places <- dec.places
result$type <- type
result$style <- style
result$percentages <- percentages
result$addmargins <- addmargins
result$subtotals <- subtotals
#(b) tabular output [3 variants]
result$table <- tbl  #Stores original cross-tab frequency counts without margins [class: table]
result$crosstab <- crosstab #Stores cross-tab in table format using requested style(frequency/pct) and table margins (on/off)
#[class: table]
result$crosstab.nosub <- t1  #crosstab with subtotals suppressed [class: dataframe; or NULL if no subtotals suppressed]
class(result) <- "crosstab"
#Return 'result' as output of function
result
}
print.crosstab <- function(x,dec.places=x$dec.places,subtotals=x$subtotals,...) {
row.vars <- x$row.vars
col.vars <- x$col.vars
n.row.vars <- length(row.vars)
n.col.vars <- length(col.vars)
n.vars <- n.row.vars + n.col.vars
if (length(x$type)>1) {
z<-length(names(dimnames(x$crosstab)))
if (x$style=="long") {
row.vars<-c(row.vars,z)
} else {
col.vars<-c(z,col.vars)
}
}
if (n.vars==1) {
if (length(x$type)==1) {
tmp <- data.frame(round(x$crosstab,x$dec.places))
colnames(tmp)[2] <- ifelse(x$type=="frequency","Count","%")
print(tmp,row.names=FALSE)
} else {
print(round(x$crosstab,x$dec.places))
}
}
#If table has only 2 dimensions, or subtotals required for >2 dimensional table,
#print table using ftable() on x$crosstab
if ((n.vars == 2) | ((subtotals==TRUE) & (n.vars>2))) {
tbl <- ftable(x$crosstab,row.vars=row.vars,col.vars=col.vars)
if (!all(as.integer(tbl)==as.numeric(tbl))) tbl <- round(tbl,dec.places)
print(tbl,...)
}
#If subtotals NOT required AND > 2 dimensions, print table using write.table() on x$crosstab.nosub
if ((subtotals==FALSE) & (n.vars>2))  {
t1 <- x$crosstab.nosub
#Convert numbers to required decimal places, right aligned
width <- max( nchar(t1[1,]), nchar(t1[2,]), 7 )
dec.places <- x$dec.places
number.format <- paste("%",width,".",dec.places,"f",sep="")
t1[3:nrow(t1),((n.row.vars+1):ncol(t1))] <- sprintf(number.format,as.numeric(t1[3:nrow(t1),((n.row.vars+1):ncol(t1))]))
#Adjust column variable label to same width as numbers, left aligned, padding with trailing spaces as required
col.var.format <- paste("%-",width,"s",sep="")
t1[1,(n.row.vars+1):ncol(t1)] <- sprintf(col.var.format,t1[1,(n.row.vars+1):ncol(t1)])
#Adjust column category labels to same width as numbers, right aligned, padding with preceding spaces as required
col.cat.format <- paste("%",width,"s",sep="")
t1[2,(n.row.vars+1):ncol(t1)] <- sprintf(col.cat.format,t1[2,(n.row.vars+1):ncol(t1)])
#Adjust row labels so that each column is of fixed width, using trailing spaces as required
for (i in 1:n.row.vars) {
width <- max(nchar(t1[,i])) + 2
row.lab.format <- paste("%-",width,"s",sep="")
t1[,i] <- sprintf(row.lab.format,t1[,i])
}
write.table(t1,quote=FALSE,col.names=FALSE,row.names=FALSE)
}
}
install.packages(p)
decrit(s$transports_travail, weights = s$weight)
decrit(s$transports_travail, weights = s$weight)
decrit(s$transports_travail[s$transports_travail!='Non concerné·e'], weights = s$weight[s$transports_travail!='Non concerné·e'])
decrit(s$transports_travail_actif=='Non' & s$transports_travail_commun=='Non', weights = s$weight)
decrit(s$transports_travail_actif=='Oui, ça ne me poserait pas de grande difficulté' | s$transports_travail_commun=='Oui, ça ne me poserait pas de grande difficulté', weights = s$weight)
decrit(s$transports_travail_actif, weights = s$weight)
decrit(s$transports_travail_actif=='Oui, ça ne me poserait pas de grande difficulté' | s$transports_travail_commun=='Oui, ça ne me poserait pas de grande difficulté', weights = s$weight)
distribution_revenu_erfs_weighted
deciles_erfs_inflates_weighted
round(deciles_erfs_inflates_weighted)
decrit(s$transports_distance, weights = s$weight)
##### Approbation ciblée #####
summary(lm(taxe_cible_approbation != 'Non' ~ cible, data=s, weights = s$weight))
