s[[k]] <<- as.item(temp, labels = structure(c(-2:2),
names = c("Beaucoup moins","Un peu moins","= Moyenne","Un peu plus","Beaucoup plus")),
# names = c("Non, beaucoup moins","Non, un peu moins","Autant que la moyenne","Oui, un peu plus","Oui, beaucoup plus")),
annotation=Label(s[[k]]))
}
for (k in c(131:139,141:148)) {
temp <-  2 * (s[k][[1]]=="Oui, tout à fait") + (s[k][[1]]=="Oui, plutôt") - (s[k][[1]]=="Non, pas vraiment") - 2 * (s[k][[1]]=="Non, pas du tout")
s[k][[1]] <<- as.item(temp, labels = structure(c(-2:2),
names = c("Pas du tout","Pas vraiment","Indifférent/NSP","Plutôt","Tout à fait")),
# names = c("Non, pas du tout","Non, pas vraiment","Indifférent ou Ne sais pas","Oui, plutôt","Oui, tout à fait")),
annotation=Label(s[k][[1]]))
}
temp <- (s$parle_CC=='Plusieurs fois par an') + 2*(s$parle_CC=='Plusieurs fois par mois') - (s$parle_CC=="NSP")
s$parle_CC <<- as.item(temp, labels = structure(c(-1:2),
names = c("NSP","Presque jamais","Plusieurs fois par an","Plusieurs fois par mois")),
missing.values = -1, annotation=Label(s$parle_CC))
temp <- grepl("Faibles", s$effets_CC) + 2*grepl("Graves", s$effets_CC) + 3*grepl("Désastreux", s$effets_CC) + 4*grepl("Cataclysmiques", s$effets_CC) - (s$effets_CC=="NSP")
s$effets_CC <<- as.item(temp, labels = structure(c(-1:4),
names = c("NSP","Insignifiants","Faibles","Graves","Désastreux","Cataclysmiques")),
# names = c("NSP","Insignifiants, voire bénéfiques","Faibles, car les humains sauraient vivre avec","Graves, car il y aurait plus de catastrophes naturelles","Désastreux, les modes de vie seraient largement altérés","Cataclysmiques, l'humanité disparaîtrait")),
missing.values = -1, annotation=Label(s$effets_CC))
temp <- (s$transports_frequence=="Entre quatre fois par jour et une fois par heure") + 2*(s$transports_frequence=="Une ou deux fois par heure") + 3*(s$transports_frequence=="Plus que trois fois par heure") - (s$transports_frequence=="NSP")
s$transports_frequence <<- as.item(temp, labels = structure(c(-1:3),
names = c("NSP","< 3/jour","1/h - 4/jour","1/h - 2/h","> 3/heure")),
# names = c("NSP","Moins de trois fois par jour","Entre quatre fois par jour et une fois par heure","Une ou deux fois par heure","Plus que trois fois par heure")),
missing.values = -1, annotation=Label(s$transports_frequence))
temp <- (s$transports_avis=="Limitée, mais suffisante") + 2*(s$transports_avis=="Convenable, mais devrait être accrue") + 3*(s$transports_avis=="Satisfaisante") - (s$transports_avis=="NSP")
s$transports_avis <<- as.item(temp, labels = structure(c(-1:3),
names = c("NSP","Insuffisante","Limitée","Convenable","Satisfaisante")),
# names = c("NSP","Insuffisante","Limitée, mais suffisante","Convenable, mais devrait être accrue","Satisfaisante")),
missing.values = -1, annotation=Label(s$transports_avis))
# TODO: decrit(s$age) not numbers (as with miss=T)
temp <- 20.90*(s$age == "18 à 24 ans") + 29.61*(s$age == "25 à 34 ans") + 42.14*(s$age == "35 à 49 ans") + 56.84*(s$age == "50 à 64 ans") + 75.43*(s$age == "65 ans ou plus")
s$age <<- as.item(temp, labels = structure(c(20.90, 29.61, 42.14, 56.84, 75.43), names = c("18-24", "25-34", "35-49", "50-64", "65+")), annotation=Label(s$age))
# s$Age <<- (s$age == "18 à 24 ans") + 2*(s$age == "25 à 34 ans") + 3.3*(s$age == "35 à 49 ans") + 4.6*(s$age == "50 à 64 ans") + 7*(s$age == "65 ans ou plus")
s$taille_agglo <<- as.item(as.numeric(s$taille_agglo), labels = structure(1:5, names = c("rural", "-20k", "20-100k", "+100k", "Paris")), annotation=Label(s$taille_agglo))
# s$compris_depenses <<- as.item(as.character(s$compris_depenses),
s$compris_depenses <<- as.item(as.character(s$compris_depenses),
labels = structure(c("","Oui","Non","Bug: le graphique ne s'est pas affiché correctement."), names = c("NA","Oui","Non","Bug")), annotation=attr(s$compris_depenses, "label"))
s$mode_chauffage <<- as.item(s$mode_chauffage,
labels = structure(c("","Chauffage individuel","Chauffage collectif", "NSP"), names = c("NA","individuel","collectif","NSP")), missing.values='NSP', annotation=Label(s$mode_chauffage))
s$chauffage <<- as.item(s$chauffage,
labels = structure(c("Gaz de ville", "Butane, propane, gaz en citerne", "Fioul, mazout, pétrole", "Électricité", "Bois, solaire, géothermie, aérothermie (pompe à chaleur)", "Autre","NSP"), names = c("Gaz réseau", "Gaz bouteille", "Fioul", "Électricité", "Bois, solaire...", "Autre", "NSP")), missing.values='NSP', annotation=Label(s$chauffage))
s$schiste_CC <<- as.item(s$schiste_CC,
labels = structure(c("","Elle est malvenue : il faudrait mettre fin aux émissions, pas seulement les ralentir","Elle est valable : toute baisse des émissions va dans la bonne direction", "NSP"), names = c("NA","malvenue","valable","NSP")), missing.values='NSP', annotation=Label(s$schiste_CC))
s$cause_CC <<- as.item(s$cause_CC,
labels = structure(c("n'est pas une réalité","est principalement dû à la variabilité naturelle du climat", "est principalement dû à l'activité humaine", "NSP"), names = c("n'existe pas","naturel","anthropique","NSP")), missing.values='NSP', annotation=Label(s$cause_CC))
s$gauche_droite <<- pmax(-2,pmin(2,-2 * grepl("extrême gauche", s$extr_gauche) - grepl("De gauche", s$gauche) + grepl("De droite", s$droite) + 2 * grepl("extrême droite", s$extr_droite)))
is.na(s$gauche_droite) <<- (s$gauche_droite == 0) & !grepl("centre", s$centre)
s$Gauche_droite <<- as.factor(s$gauche_droite)
s$gauche_droite <<- as.item(as.numeric(as.vector(s$gauche_droite)), labels = structure(c(-2:2),
names = c("Extrême gauche","Gauche","Centre","Droite","Extrême droite")), annotation=attr(s$gauche_droite, "label"))
levels(s$Gauche_droite) <<- c("Extreme-left", "Left", "Center", "Right", "Extreme-right", "Indeterminate")
s$Gauche_droite[is.na(s$Gauche_droite)] <<- "Indeterminate"
# temp <- label(s$diplome)
# s$diplome <<- factor(s$diplome, c("","Aucun diplôme","Brevet des collèges","CAP ou BEP","Baccalauréat","Bac +2 (BTS, DUT, DEUG, écoles de formation sanitaires et sociales...)","Bac +3 (licence...)","Bac +5 ou plus (master, école d'ingénieur ou de commerce, doctorat, médecine, maîtrise, DEA, DESS...)","NSP (Ne se prononce pas)") )
# label(s$diplome) <<- temp
# temp <- label(s$interet_politique)
# s$interet_politique <<- factor(s$interet_politique, c("","Beaucoup","Un peu","Presque pas (ou pas du tout)","NSP","NSP (Je ne veux pas répondre)","Q20 - À quel point êtes-vous intéressé·e par la politique ?"))
# label(s$interet_politique) <<- temp
s$revenu_conjoint <<- s$rev_tot - s$revenu
s$revdisp <<- round((s$rev_tot -  irpp(s$rev_tot, s$nb_adultes, s$taille_menage)))
s$uc <<- uc(s$taille_menage, s$nb_14_et_plus)
s$niveau_vie <<- s$revdisp / s$uc
# s$age <<- as.factor(as.character(s$age))
s$Diplome <<- (s$diplome == "Brevet des collèges") + 2*(s$diplome=="CAP ou BEP") + 3*(s$diplome=="Baccalauréat") + 4*(s$diplome=="Bac +2 (BTS, DUT, DEUG, écoles de formation sanitaires et sociales...)") + 5*(s$diplome=="Bac +3 (licence...)") + 6*(s$diplome=="Bac +5 ou plus (master, école d'ingénieur ou de commerce, doctorat, médecine, maîtrise, DEA, DESS...)") - (s$diplome=="NSP (Ne se prononce pas)")
s$diplome4 <<- as.character(s$diplome)
s$diplome4[s$Diplome<2] <<- "Aucun diplôme ou brevet"
s$diplome4[s$Diplome>3] <<- "Supérieur"
# s$Region <<- as.factor(as.character(s$region))
# s$taille_agglo <<- as.factor(gsub("[[:alpha:] ]", "", s$taille_agglo))
# s <<- s[s$taille_agglo!="%1%",]
# pourquoi 91 missing regions? Sûrement un bug du Javascript côté utilisateur (certains types de device/navigateur?): 56% ont un bug sur compris_depenses contre 3% pour les autres
region_code <- function(code) {
reg <- "autre"
regions <- list(
"ARA" = c('01', '03', '07', '15', '26', '38', '42', '43', '63', '69', '73', '74'),
"Est" = c('21', '25', '39', '58', '70', '71', '89', '90', '08', '10', '51', '52', '54', '55', '57', '67', '68', '88'),
"Ouest" = c('22', '29', '35', '56', '14', '27', '50', '61', '76' ),
"Centre" = c('18', '28', '36', '37', '41', '45', '44', '49', '53', '72', '85'),
"Nord" = c('02', '59', '60', '62', '80'),
"IDF" = c('75', '77', '78', '91', '92', '93', '94', '95'),
"SO" = c('16', '17', '19', '23', '24', '33', '40', '47', '64', '79', '86', '87'),
"Occ" = c('09', '11', '12', '30', '31', '32', '34', '46', '48', '65', '66', '81', '82'),
"PACA" = c( '04', '05', '06', '13', '83', '84')
)
for (i in 1:9) if (as.numeric(code) %in% as.numeric(regions[[i]])) reg <- names(regions)[i]
return(reg)
}
region_dep <- rep("", 95)
for (i in 1:95) region_dep[i] <- region_code(i)
s$region <<- "autre"
s$region[as.numeric(substr(s$code_postal, 1, 2)) %in% 1:95] <<- region_dep[as.numeric(substr(s$code_postal, 1, 2))]
s$nb_vehicules <<- (s$nb_vehicules_texte=='Un') + 2*(s$nb_vehicules_texte=='Deux ou plus')
s$variante_partielle <<- 'NA'
s$variante_partielle[!is.na(s$gain_taxe_chauffage)] <<- 'c'
s$variante_partielle[!is.na(s$gain_taxe_fuel)] <<- 'f'
label(s$variante_partielle) <<- "variante_partielle: Variante aléatoire (c/f) de la taxe partielle sur le chauffage ou les carburants (=fuel)"
s$perte_partielle[s$variante_partielle=='c'] <<- s$perte_chauffage[s$variante_partielle=='c']
s$perte_partielle[s$variante_partielle=='f'] <<- s$perte_fuel[s$variante_partielle=='f']
label(s$perte_partielle) <<- "perte_partielle: Une hausse des taxes sur variante_partielle (chauffage ou fuel) ferait perdre plus à votre ménage que la moyenne (Oui, beaucoup/un peu plus/Autant que la moyenne/Non, un peu/beaucoup moins/NSP) - Q155, 162"
# s$gain_fuel <- NA
s$gain_fuel[s$gain_taxe_fuel=='Non affecté' & s$variante_partielle=='f'] <<- 0
s$gain_fuel[s$gain_taxe_fuel=='Gagnant' & s$variante_partielle=='f'] <<- 1 + as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_fuel_hausse[s$gain_taxe_fuel=='Gagnant' & s$variante_partielle=='f']))))/25
s$gain_fuel[s$gain_taxe_fuel=='Perdant' & s$variante_partielle=='f'] <<- - 1 - as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_fuel_baisse[s$gain_taxe_fuel=='Perdant' & s$variante_partielle=='f']))))/25
label(s$gain_fuel) <<- "gain_fuel: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe carburants compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40)"
s$gain_chauffage[s$gain_taxe_chauffage=='Non affecté' & s$variante_partielle=='c'] <<- 0
s$gain_chauffage[s$gain_taxe_chauffage=='Gagnant' & s$variante_partielle=='c'] <<- 1 + as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_chauffage_hausse[s$gain_taxe_chauffage=='Gagnant' & s$variante_partielle=='c']))))/25
s$gain_chauffage[s$gain_taxe_chauffage=='Perdant' & s$variante_partielle=='c'] <<- - 1 - as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_chauffage_baisse[s$gain_taxe_chauffage=='Perdant' & s$variante_partielle=='c']))))/25
label(s$gain_chauffage) <<- "gain_fuel: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe chauffage compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40)"
s$gain[s$gain_taxe=='Non affecté' & s$variante_partielle!='NA'] <<- 0
s$gain[s$gain_taxe=='Gagnant' & s$variante_partielle!='NA'] <<- 1 + as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_hausse[s$gain_taxe=='Gagnant' & s$variante_partielle!='NA']))))/50
s$gain[s$gain_taxe=='Perdant' & s$variante_partielle!='NA'] <<- - 1 - as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_baisse[s$gain_taxe=='Perdant' & s$variante_partielle!='NA']))))/50
label(s$gain) <<- "gain: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe carbone compensée, dans [-6;5] (seuils: -280/-190/-120/-70/-30/0/20/40/60/80)"
# cf. consistency_belief_losses.py pour les imputations
temp <- -405.55*(s$gain==-6) - 224.25*(s$gain==-5) - 147.91*(s$gain==-4) - 92.83*(s$gain==-3) - 48.28*(s$gain==-2) - 13.72*(s$gain==-1) + 10.39*(s$gain==1) + 30.36*(s$gain==2) + 49.96*(s$gain==3) + 69.72*(s$gain==4) + 106.89*(s$gain==5) #  - 1.66*(s$gain==0)
s$gain <<- as.item(temp, labels = structure(c(-405.55, -224.25, -147.91, -92.83, -48.28, -13.72, 0, 10.39, 30.36, 49.96, 69.72, 106.89), names = c("<-280", "-280_-190", "-190_-120", "-120_-70", "-70_-30", "-30_0", "0", "0_20", "20_40", "40_60", "60_80", ">80")), annotation=Label(s$gain))
temp <- NA
temp[!is.na(s$gain_fuel)] <- (-248.76*(s$gain_fuel==-6) - 131.21*(s$gain_fuel==-5) - 87.36*(s$gain_fuel==-4) - 53.27*(s$gain_fuel==-3) - 25.49*(s$gain_fuel==-2) - 7.51*(s$gain_fuel==-1) + 5.17*(s$gain_fuel==1) + 14.73*(s$gain_fuel==2) + 24.85*(s$gain_fuel==3) + 34.89*(s$gain_fuel==4) + 57.42*(s$gain_fuel==5))[!is.na(s$gain_fuel)] #  - 1.17*(s$gain_fuel==0)
s$gain_fuel <<- as.item(temp, labels = structure(c(-248.76, -131.21, -87.36, -53.27, -25.49, -7.51, 0, 5.17, 14.73, 24.85, 34.89, 57.42), names = c("<-160", "-160_-110", "-110_-70", "-70_-40", "-40_-15", "-15_0", "0", "0_10", "10_20", "20_30", "30_40", ">40")), annotation=Label(s$gain_fuel))
temp <- NA
temp[!is.na(s$gain_chauffage)] <- (-262.07*(s$gain_chauffage==-6) - 132.69*(s$gain_chauffage==-5) - 87.05*(s$gain_chauffage==-4) - 53.65*(s$gain_chauffage==-3) - 26.57*(s$gain_chauffage==-2) - 7.20*(s$gain_chauffage==-1) + 4.53*(s$gain_chauffage==1) + 15.44*(s$gain_chauffage==2) + 25.26*(s$gain_chauffage==3) + 35.66*(s$gain_chauffage==4) + 54.67*(s$gain_chauffage==5))[!is.na(s$gain_chauffage)] #  - 1.34*(s$gain_chauffage==0)
s$gain_chauffage <<- as.item(temp, labels = structure(c(-262.07, -132.69, -87.05, -53.65, -26.57, -7.20, 0, 4.53, 15.44, 25.26, 35.66, 54.67), names = c("<-160", "-160_-110", "-110_-70", "-70_-40", "-40_-15", "-15_0", "0", "0_10", "10_20", "20_30", "30_40", ">40")), annotation=Label(s$gain_chauffage))
s$Elasticite_chauffage <<- as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$elasticite_chauffage))))
s$Elasticite_chauffage <<- (s$Elasticite_chauffage==0)*1.5 + (s$Elasticite_chauffage==3)*6.5 + (s$Elasticite_chauffage>3)*(s$Elasticite_chauffage + 5) # Take the average of thresholds, take 40% for >30%
s$Elasticite_chauffage <<- - round(s$Elasticite_chauffage / 30, 2) # converts into elasticity
label(s$Elasticite_chauffage) <<- "Elasticite_chauffage: Élasticité-prix des dépenses de chauffage des Français, calculée en prenant la valeur moyenne des intervalles proposées (seuils à 0/3/10/20/30% pour une hausse de 30%)"
s$Elasticite_chauffage_perso <<- as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$elasticite_chauffage_perso))))
s$Elasticite_chauffage_perso <<- (s$Elasticite_chauffage_perso==0)*1.5 + (s$Elasticite_chauffage_perso==3)*6.5 + (s$Elasticite_chauffage_perso>3)*(s$Elasticite_chauffage_perso + 5) # Take the average of thresholds, take 40% for >30%
s$Elasticite_chauffage_perso <<- - round(s$Elasticite_chauffage_perso / 30, 2) # converts into elasticity
label(s$Elasticite_chauffage_perso) <<- "Elasticite_chauffage_perso: Élasticité-prix des dépenses de chauffage du ménage, calculée en prenant la valeur moyenne des intervalles proposées (seuils à 0/3/10/20/30% pour une hausse de 30%)"
s$Elasticite_fuel <<- as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$elasticite_fuel))))
s$Elasticite_fuel <<- (s$Elasticite_fuel==0)*1.5 + (s$Elasticite_fuel==3)*6.5 + (s$Elasticite_fuel>3)*(s$Elasticite_fuel + 5) # Take the average of thresholds, take 40% for >30%
s$Elasticite_fuel <<- - round(s$Elasticite_fuel / 30, 2) # converts into elasticity
label(s$Elasticite_fuel) <<- "Elasticite_fuel: Élasticité-prix des dépenses de carburants des Français, calculée en prenant la valeur moyenne des intervalles proposées (seuils à 0/3/10/20/30% pour une hausse de 0.5€/L)"
s$Elasticite_fuel_perso <<- as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$elasticite_fuel_perso))))
s$Elasticite_fuel_perso <<- (s$Elasticite_fuel_perso==0)*1.5 + (s$Elasticite_fuel_perso==3)*6.5 + (s$Elasticite_fuel_perso>3)*(s$Elasticite_fuel_perso + 5) # Take the average of thresholds, take 40% for >30%
s$Elasticite_fuel_perso <<- - round(s$Elasticite_fuel_perso / 30, 2) # converts into elasticity
label(s$Elasticite_fuel_perso) <<- "Elasticite_fuel_perso: Élasticité-prix des dépenses de carburants du ménage, calculée en prenant la valeur moyenne des intervalles proposées (seuils à 0/3/10/20/30% pour une hausse de 0.5€/L)"
s$variante_taxe_info <<- "p"
s$variante_taxe_info[s$gain_taxe_feedback!=""] <<- "f"
label(s$variante_taxe_info) <<- "variante_taxe_info: (f/p) Variante aléatoire entre f: feedback (=simulation, 2/3) et p: progressivité (1/3), dans l'information donnée sur la taxe compensée avant de demander à nouveau le gain et l'approbation, ainsi que les bénéfices et problèmes"
for (v in c('CC', 'sante', 'circulation', 'revenu', 'pauvres', 'independance', 'enjeu', 'aucun', 'autre_choix', 'autre')) {
s[[paste('taxe_benefices_', v, sep="")]] <<- s[paste('taxe_benefices_', v, '_p', sep="")][[1]]
s[[paste('taxe_benefices_', v, sep="")]][s$variante_taxe_info=='f'] <<- s[paste('taxe_benefices_', v, '_f', sep="")][[1]][s$variante_taxe_info=='f']
label(s[[paste('taxe_benefices_', v, sep="")]]) <<- sub("_f: \\* ", ": ", label(s[paste('taxe_benefices_', v, '_f', sep="")][[1]]))
}
for (v in c('inefficace', 'alternatives', 'ruraux', 'revenu', 'pauvres', 'economie', 'pretexte', 'aucun', 'autre_choix', 'autre')) {
s[[paste('taxe_problemes_', v, sep="")]] <<- s[paste('taxe_problemes_', v, '_p', sep="")][[1]]
s[[paste('taxe_problemes_', v, sep="")]][s$variante_taxe_info=='f'] <<- s[paste('taxe_problemes_', v, '_f', sep="")][[1]][s$variante_taxe_info=='f']
label(s[[paste('taxe_problemes_', v, sep="")]]) <<- sub("_f: \\* ", ": ", label(s[paste('taxe_problemes_', v, '_f', sep="")][[1]]))
}
s$cible[s$cible20==1] <<- 20
s$cible[s$cible30==1] <<- 30
s$cible[s$cible40==1] <<- 40
s$cible[s$cible50==1] <<- 50
label(s$cible) <<- "cible: Ciblage du recyclage de la hausse de la taxe carbone, attribué en fonction du revenu du répondant et de son ménage (20/30/40/50% les plus modestes)"
# TODO: manage to use tidyverse without erasing observations
# s <<- merge(s, s %>% gather(key = temp, value = gain_cible, c(gain_taxe__20, gain_taxe_20_30, gain_taxe_30_40, gain_taxe_40_50, gain_taxe_50_70, gain_taxe_70_)) %>% filter(gain_cible != "") %>% select(-temp), sort=FALSE) # Warning: attributes are not identical across measure variables; they will be dropped
# label(s$gain_cible) <<- "gain_cible: Ménage Gagnant/Non affecté/Perdant avec hausse taxe carbone à recyclage ciblé (cible: 20/30/40/50% les plus modestes)"
# s <<- merge(s, s %>% gather(key = temp, value = taxe_cible_approbation, c(taxe__20_approbation, taxe_20_30_approbation, taxe_30_40_approbation, taxe_40_50_approbation, taxe_50_70_approbation, taxe_70__approbation)) %>% filter(taxe_cible_approbation != "") %>% select(-temp), sort=FALSE)
# label(s$taxe_cible_approbation) <<- "taxe_cible_approbation: Approbation d'une hausse de la taxe carbone compensée par recyclage ciblé (cible: 20/30/40/50% les plus modestes)"
#
#   # s <<- s %>% gather(key = temp, value = km, c(km_0, km_1, km_2)) %>% filter(km != "") %>% select(-temp) # erases km_0, km_1, km_2
# s <<- merge(s, s %>% gather(key = temp, value = km, c(km_0, km_1, km_2)) %>% filter(km != "") %>% select(-temp), sort=FALSE) # Warning: attributes are not identical across measure variables; they will be dropped
# label(s$km) <<- "km: Nombre de kilomètres parcourus lors des 12 derniers mois en voiture ou moto (par le répondant pour nb_vehicules=0, par les véhicules sinon)"
#
# s <<- merge(s, s %>% gather(key = temp, value = conso, c(conso_1, conso_2)) %>% filter(conso != "") %>% select(-temp), sort=FALSE)
# label(s$conso) <<- "conso:  Consommation moyenne du véhicule (en litres aux 100 km)"
s$gain_cible[!is.na(s$gain_taxe__20)] <<- s$gain_taxe__20[!is.na(s$gain_taxe__20)]
s$gain_cible[!is.na(s$gain_taxe_20_30)] <<- s$gain_taxe_20_30[!is.na(s$gain_taxe_20_30)]
s$gain_cible[!is.na(s$gain_taxe_30_40)] <<- s$gain_taxe_30_40[!is.na(s$gain_taxe_30_40)]
s$gain_cible[!is.na(s$gain_taxe_40_50)] <<- s$gain_taxe_40_50[!is.na(s$gain_taxe_40_50)]
s$gain_cible[!is.na(s$gain_taxe_50_70)] <<- s$gain_taxe_50_70[!is.na(s$gain_taxe_50_70)]
s$gain_cible[!is.na(s$gain_taxe_70_)] <<- s$gain_taxe_70_[!is.na(s$gain_taxe_70_)]
label(s$gain_cible) <<- "gain_cible: Ménage Gagnant/Non affecté/Perdant avec hausse taxe carbone à recyclage ciblé (cible: 20/30/40/50% les plus modestes)"
s$taxe_cible_approbation[!is.na(s$taxe__20_approbation)] <<- s$taxe__20_approbation[!is.na(s$taxe__20_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_20_30_approbation)] <<- s$taxe_20_30_approbation[!is.na(s$taxe_20_30_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_30_40_approbation)] <<- s$taxe_30_40_approbation[!is.na(s$taxe_30_40_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_40_50_approbation)] <<- s$taxe_40_50_approbation[!is.na(s$taxe_40_50_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_50_70_approbation)] <<- s$taxe_50_70_approbation[!is.na(s$taxe_50_70_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_70__approbation)] <<- s$taxe_70__approbation[!is.na(s$taxe_70__approbation)]
label(s$taxe_cible_approbation) <<- "taxe_cible_approbation: Approbation d'une hausse de la taxe carbone compensée par recyclage ciblé (cible: 20/30/40/50% les plus modestes)"
s$categorie_cible[!is.na(s$taxe__20_approbation)] <<- '_20'
s$categorie_cible[!is.na(s$taxe_20_30_approbation)] <<- '20_30'
s$categorie_cible[!is.na(s$taxe_30_40_approbation)] <<- '30_40'
s$categorie_cible[!is.na(s$taxe_40_50_approbation)] <<- '40_50'
s$categorie_cible[!is.na(s$taxe_50_70_approbation)] <<- '50_70'
s$categorie_cible[!is.na(s$taxe_70__approbation)] <<- '70_'
label(s$categorie_cible) <<- "categorie_cible: Catégorie de revenu du répondant (et de son ménage) taxe à recyclage ciblé - Catégories: percentile <20/20-30/30-40/40-50/50-70/>70, sachant que revenu_conjoint détermine la catégorie quand percentile de revenu > 70 (780/1140/1430/1670/2220)"
s$km[!is.na(s$km_0)] <<- s$km_0[!is.na(s$km_0)]
s$km[!is.na(s$km_1)] <<- s$km_1[!is.na(s$km_1)]
s$km[!is.na(s$km_2)] <<- s$km_2[!is.na(s$km_2)]
label(s$km) <<- "km: Nombre de kilomètres parcourus lors des 12 derniers mois en voiture ou moto (par le répondant pour nb_vehicules=0, par les véhicules sinon)"
s$conso[!is.na(s$conso_1)] <<- s$conso_1[!is.na(s$conso_1)]
s$conso[!is.na(s$conso_2)] <<- s$conso_2[!is.na(s$conso_2)]
label(s$conso) <<- "conso:  Consommation moyenne du véhicule (en litres aux 100 km)"
s$gaz <<- grepl('gaz', s$chauffage, ignore.case = T)
s$fioul <<- grepl('fioul', s$chauffage, ignore.case = T)
s$hausse_chauffage <<- -55.507189 + s$gaz * 124.578484 + s$fioul * 221.145441 + s$surface * 0.652174
s$hausse_diesel[s$nb_vehicules == 0] <<- (0.5*(6.39/100) * s$km * 1.4 * (1 - 0.4) * 0.090922)[s$nb_vehicules == 0] # share_diesel * conso * km * price * (1-elasticite) * price_increase
s$hausse_diesel[s$nb_vehicules == 1] <<- ((s$fuel_1=='Diesel') * (s$conso/100) * s$km * 1.4 * (1 - 0.4) * 0.090922)[s$nb_vehicules == 1]
s$hausse_diesel[s$nb_vehicules == 2] <<- (((s$fuel_2_1=='Diesel')*2/3 + (s$fuel_2_2=='Diesel')/3) * (s$conso/100) * s$km * 1.4 * (1 - 0.4) * 0.090922)[s$nb_vehicules == 2]
s$hausse_essence[s$nb_vehicules == 0] <<- (0.5*(7.31/100) * s$km * 1.45 * (1 - 0.4) * 0.076128)[s$nb_vehicules == 0] # share_diesel * conso * km * price * (1-elasticite) * price_increase
s$hausse_essence[s$nb_vehicules == 1] <<- ((s$fuel_1!='Diesel') * (s$conso/100) * s$km * 1.45 * (1 - 0.4) * 0.076128)[s$nb_vehicules == 1]
s$hausse_essence[s$nb_vehicules == 2] <<- (((s$fuel_2_1!='Diesel')*2/3 + (s$fuel_2_2!='Diesel')/3) * (s$conso/100) * s$km * 1.45 * (1 - 0.4) * 0.076128)[s$nb_vehicules == 2]
s$hausse_carburants <<- s$hausse_diesel + s$hausse_essence
label(s$hausse_carburants) <<- "hausse_carburant: Hausse des dépenses de carburants simulées pour le ménage, suite à la taxe (élasticité de 0.4) (hausse_diesel + hausse_essence)"
s$hausse_depenses <<- s$hausse_carburants + s$hausse_chauffage
s$diesel <<- (!is.na(s$fuel_1) & (s$fuel_1=='Diesel')) | (!is.na(s$fuel_2_2) & ((s$fuel_2_1=='Diesel') | (s$fuel_2_2=='Diesel')))
s$essence <<- (!is.na(s$fuel_1) & (s$fuel_1=='Essence')) | (!is.na(s$fuel_2_2) & ((s$fuel_2_1=='Essence') | (s$fuel_2_2=='Essence')))
label(s$diesel) <<- "diesel: Indicatrice de la possession d'un véhicule diesel par le ménage (fuel_1 ou fuel_2_1 ou fuel_2_2 = 'Diesel')"
label(s$essence) <<- "essence: Indicatrice de la possession d'un véhicule à essence par le ménage (fuel_1 ou fuel_2_1 ou fuel_2_2 = 'Essence')"
s$progressivite[!is.na(s$progressivite_feedback_sans_info)] <<- s$progressivite_feedback_sans_info[!is.na(s$progressivite_feedback_sans_info)]
s$progressivite[!is.na(s$progressivite_feedback_avec_info)] <<- s$progressivite_feedback_avec_info[!is.na(s$progressivite_feedback_avec_info)]
s$progressivite[!is.na(s$progressivite_progressif)] <<- s$progressivite_progressif[!is.na(s$progressivite_progressif)]
label(s$progressivite) <<- "progressivite: ~ Une hausse de la taxe carbone compensée avantagerait les plus modestes (réunion des trois variante_progressivite: prog/fb_info/fb_no_info où seule fb_no_info est sans information préalable sur la progressivité) - Q206-208"
s$variante_progressivite[!is.na(s$progressivite_feedback_sans_info)] <<- "fb_no_info"
s$variante_progressivite[!is.na(s$progressivite_feedback_avec_info)] <<- "fb_info"
s$variante_progressivite[!is.na(s$progressivite_progressif)] <<- "prog"
label(s$variante_progressivite) <<- "variante_progressivite: prog/fb_info/fb_no_info Variante aléatoire du bloc de questions où figure 'progressivite', seulement pour apres_modifs=T. prog: info sur la progressivité / fb: feedback sur le statut gagnant/perdant simulé, info/no_info: avec/sans info sur la progressivité de la mesure"
s$info_progressivite <<- FALSE
s$info_progressivite[s$variante_taxe_info=='p' | s$variante_progressivite=='fb_info'] <<- T
label(s$info_progressivite) <<- "info_progressivite: Indicatrice qu'a été montrée l'information que la hausse de la taxe carbone compensée avantagerait les plus modestes"
s$age_18_24 <<- 1*(s$age == '18 à 24 ans')
s$age_25_34 <<- 1*(s$age == '25 à 34 ans')
s$age_35_49 <<- 1*(s$age == '35 à 49 ans')
s$age_50_64 <<- 1*(s$age == '50 à 64 ans')
s$age_65_plus <<- 1*(s$age == '65 ans ou plus')
s$score_ges <<- 1 * (s$ges_CO2 == TRUE) + 1*(s$ges_CH4 == TRUE) + 1*(s$ges_O2 == FALSE) + 1*(s$ges_pm == FALSE)
label(s$score_ges) <<- "score_ges: Somme des bonnes réponses au questionnaire gaz à effet de serre (ges_O2/CH4/pm/CO2)"
s$score_climate_call <<- 1*(s$ges_avion == TRUE) + 1*(s$ges_boeuf == TRUE) + 1*(s$ges_nucleaire == FALSE)
label(s$score_climate_call) <<- "score_climate_call: Somme des bonnes réponses au questionnaire Climate Call (avion-train / boeuf-pates / nucleaire-eolien) ges_avion/boeuf/nucleaire"
for (v in c("autonomie", "priorite", "etats", "global", "trop")) {
s[[paste("aide_non", v, sep="_")]] <<- NA
s[[paste("aide_non", v, sep="_")]][s$transferts_inter_info==T & s$aide_2p==T] <<- s[[paste("aide_non", v, "i", sep="_")]]
s[[paste("aide_non", v, sep="_")]][s$transferts_inter_info==FALSE & s$aide_2p==T] <<- s[[paste("aide_non", v, "ni", sep="_")]]
label(s[[paste("aide_non", v, sep="_")]]) <<- Label(s[[paste("aide_non", v, "i", sep="_")]])
}
for (i in 0:10) s[[paste('dep', i, 'en_position', sep='_')]] <<- NA
for (i in 0:10) {
for (o in 1:nrow(s)) {
j <- s[[paste('en_position', i, sep='_')]][o]
if (!is.na(j)) s[[paste('dep', j, 'en_position', sep='_')]][o] <<- i
}
}
# TODO: remove useless colonnes, such as _f/_p
# TODO: qualité, connaissances CC, opinions CC, gilets jaunes, duree_info, perte_tva/fuel, si_/non_, gaz-fioul -> T/F, transferts_inter/variante, enfant
}
# convert_s()
# prepare_s(exclude_screened=FALSE, exclude_speeder=FALSE, only_finished=FALSE)
# sa <- s
# prepare_s()
weighting_s <- function(data, printWeights = T) { # cf. google sheet
d <- data
d$region[is.na(d$region)] <- 'autre'
d$taille_agglo <- as.numeric(d$taille_agglo)
# d$csp <- factor(d$csp)
# d$region <- factor(d$region)
# levels(d$csp) <- c(levels(d$csp),"missing")
# levels(d$region) <- c(levels(d$region),"missing")
# levels(d$taille_agglo) <- c(levels(d$taille_agglo),"missing")
# levels(d$sexe) <- c(levels(d$sexe),"missing")
# d$csp[is.na(d$csp) | d$csp=="" | d$csp=="NSP"] <- "missing"
# d$taille_agglo[is.na(d$taille_agglo)] <- "missing"
# d$sexe[d$sexe=="" | d$sexe=="Autre"] <- "missing"
unweigthed <- svydesign(ids=~1, data=d)
sexe <- data.frame(sexe = c("Féminin", "Masculin"), Freq=nrow(d)*c(0.516,0.484)) # http://www.insee.fr/fr/themes/detail.asp?ref_id=bilan-demo&reg_id=0&page=donnees-detaillees/bilan-demo/pop_age2.htm
csp <- data.frame(csp = c("Inactif", "Ouvrier", "Cadre", "Indépendant", "Intermédiaire", "Retraité", "Employé", "Agriculteur"),
Freq=nrow(d)*c(0.1244,0.1214,0.0943,0.0341,0.1364,0.3279,0.1535,0.008))
region <- data.frame(region = c("autre","ARA", "Est", "Nord", "IDF", "Ouest", "SO", "Occ", "Centre", "PACA"),
Freq=nrow(d)*c(0.001,0.124,0.129,0.093,0.189,0.103,0.093,0.091,0.099,0.078))
age <- data.frame(age = c("18-24", "25-34", "35-49", "50-64", "65+"),
Freq=nrow(d)*c(0.117,0.147,0.242,0.242,0.252)) # Données/estim-pop-reg-sexe...
taille_agglo <- data.frame(taille_agglo = c(1:5), Freq=nrow(d)*c(0.2166,0.1710,0.1408,0.3083,0.1633))
# revenu <- data.frame(revenu = c(), Freq=nrow(d)*c())
diplome4 <- data.frame(diplome4 = c("Aucun diplôme ou brevet", "CAP ou BEP", "Baccalauréat", "Supérieur"),  # http://webcache.googleusercontent.com/search?q=cache:rUvf6u0uCnEJ:www.insee.fr/fr/themes/tableau.asp%3Freg_id%3D0%26ref_id%3Dnattef07232+&cd=1&hl=fr&ct=clnk&gl=fr&lr=lang_en%7Clang_es%7Clang_fr
Freq=nrow(d)*c(0.301, 0.246, 0.168, 0.285))
if (length(which(d$taille_agglo==""))>0) raked <- rake(design= unweigthed, sample.margins = list(~sexe,~diplome4,~region,~csp,~age),
population.margins = list(sexe,diplome4,region,csp,age))
else raked <- rake(design= unweigthed, sample.margins = list(~sexe,~diplome4,~taille_agglo,~region,~csp,~age),
population.margins = list(sexe,diplome4,taille_agglo,region,csp,age))
if (printWeights) {    print(summary(weights(raked))  )
print(sum( weights(raked) )^2/(length(weights(raked))*sum(weights(raked)^2)) ) # <0.5 : problématique
print( length(which(weights(raked)<0.25 | weights(raked)>4))/ length(weights(raked)))
}
return(weights(trimWeights(raked, lower=0.25, upper=4, strict=TRUE)))
}
prepare_s <- function(exclude_speeder=TRUE, exclude_screened=TRUE, only_finished=TRUE) { # , exclude_quotas_full=TRUE
# setwd("/home/adrien/Google Drive/Economie/Travail/enquete/codes")
# setwd("C:/Users/a.fabre/Google Drive/Economie/Travail/enquete/codes")
# pes <<- read.csv("fin.csv", sep=";")
# s <<- read.delim("politique.tsv", fileEncoding="UTF-16")
# f_data <- read.delim("fin.tsv", fileEncoding="UTF-16")
s <<- read_csv("survey.csv")
for (i in 1:length(s)) { label(s[[i]]) <<- toString(s[i][[1]][1]) } # Use the first line to create variable names labels then remove it - to run only once
s <<- s[-c(1,2),c(1:91,94:115,117:235,241,247:310,313:319,92,93,116,311,312,236:240,242:246)]
# if (exclude_screened) { s <<- s[s$Q_TerminateFlag=="",] } # remove Screened
# if (exclude_speeder) { s <<- s[n(s$`Duration (in seconds)`) > 540,] } # remove speedest
# if (exclude_quotas_full) { s <<- s[s[101][[1]] %in% c(1:5),]  } # remove those with a problem for the taille d'agglo
# if (exclude_quotas_full) { s <<- s[s$Q_TerminateFlag=="",]  } # remove those with a problem for the taille d'agglo
# if (only_finished) { s <<- s[as.vector(s$Finished)=="True",] }
relabel_and_rename_s()
s$fini[s$exclu=="QuotaMet"] <<- "False"
if (exclude_screened) { s <<- s[is.na(s$exclu),] } # remove Screened
if (exclude_speeder) { s <<- s[as.numeric(as.vector(s$duree)) > 420,] } # remove speedest /!\ was 540 before 22-02-11:00 (EST Coast time)
# if (exclude_quotas_full) { s <<- s[s[101][[1]] %in% c(1:5),]  } # remove those with a problem for the taille d'agglo
# if (exclude_quotas_full) { s <<- s[s$Q_TerminateFlag=="",]  } # remove those with a problem for the taille d'agglo
if (only_finished) { s <<- s[s$fini=="True",] }
print(paste(length(which(is.na(s$taille_agglo))), "tailles d'agglo sont manquantes"))
s <<- s[!is.na(s$taille_agglo),]
convert_s() # TODO: check the Warnings
s$sample <<- "a"
s$sample[s$fini=="True"] <<- "e"
s$sample[s$fini=="True" & n(s$duree) > 540] <<- "p"
s$sample[s$fini=="True" & n(s$duree) > 540 & s$test_qualite=='Un peu'] <<- "f" # "q"? excluded because out of quotas
s$sample[s$fini=="True" & n(s$duree) > 540 & s$exclu==""] <<- "r"
# s <<- s[-which(is.element(s$id, s$id[duplicated(s$id)]) & !duplicated(s$id)),] # TODO: check duplicates
s$weight <<- weighting_s(s)
}
prepare_s(exclude_screened=FALSE, exclude_speeder=FALSE, only_finished=T) # TODO: let only_finished = FALSE
sa <- s
# prepare_s(exclude_screened=FALSE, exclude_speeder=FALSE)
# se <- s
# prepare_s(exclude_screened=FALSE)
# sp <- s
prepare_s()
# write.csv(s, "survey_prepared.csv")
summary(lm((taxe_approbation=='Oui') ~ ecologiste + conservateur, data=s))
variables_big_regression <- c("revenu", "rev_tot", "hausse_carburants", "hausse_chauffage", "score_climate_call", "score_ges", "Gauche_droite",
"emission_cible", "effets_CC", "ecologiste", "conservateur", "liberal", "humaniste", "patriote", "apolitique",
"sexe", "age", "diplome4", "statut_emploi", "csp", "region")
ols <- summary(lm(as.formula(paste("(taxe_approbation=='Oui') ~", paste(variables_big_regression, collapse=' + '))), data=s))
ols
anova <- summary(aov(as.formula(paste("(taxe_approbation=='Oui') ~", paste(variables_big_regression, collapse=' + '))), data=s))
anova
sum_sq <- anova[[1]]$'Sum Sq'
explained_variance <- sum(sum_sq[-length(sum_sq)])
print(paste("Share of explained variance: ", round(explained_variance/sum(sum_sq), 2), ". Among which, share of explained variance explained by each variable:", sep=""))
for (i in 1:length(variables_big_regression)) print(paste(variables_big_regression[order(sum_sq[-length(sum_sq)], decreasing = T)][i], round(sort(sum_sq[-length(sum_sq)], decreasing = T)[i]/explained_variance,3)))
ols
for (v in variables_big_regression) { # display and remove variables with missing values
na_v <- length(which(is.na(s[[v]])))
# if ("labelled" %in% class(s[[v]])) na_v <- length(which(is.na(s[[v]]))) #
# else na_v <- length(which(is.missing(s[[v]])))
if (na_v>0) {
print(paste(v, na_v))
variables_big_regression <- variables_big_regression[variables_big_regression!=v] }
}
x <- model.matrix(as.formula(paste("(taxe_approbation=='Oui') ~", paste(variables_big_regression, collapse=' + '))),  data=s)
y <- ifelse(s$taxe_approbation=="Oui", 1, 0)
#perform grid search to find optimal value of lambda
#family= binomial => logistic regression, alpha=1 => lasso
# check docs to explore other type.measure options
cv.out <- glmnet(x, y, alpha=1, family="binomial", weights = s$weight, type.multinomial = "grouped") # TODO: how to choose alpha?; run parallel computing: parallel = T
plot(cv.out)
coefs_lasso <- coef(cv.out, s="lambda.1se") # lambda.min lambda.1se
coefs_lasso <- coef(cv.out, s="lambda.min") # TODO: group variables
data.frame(name = coefs_lasso@Dimnames[[1]][coefs_lasso@i + 1], coefficient = coefs_lasso@x)
selected_variables <- coefs_lasso@i - 1
selected_variables <- selected_variables[selected_variables > 0 & selected_variables <= length(variables_big_regression)]
selected_variables <- variables_big_regression[selected_variables]
summary(glm(as.formula(paste("(taxe_approbation=='Oui') ~", paste(selected_variables, collapse=' + '))), binomial, data=s, weights=s$weight))
selected_variables
#perform grid search to find optimal value of lambda
#family= binomial => logistic regression, alpha=1 => lasso
# check docs to explore other type.measure options
cv.out <- cv.glmnet(x, y, alpha=1, family="binomial", weights = s$weight, type.multinomial = "grouped") # TODO: how to choose alpha?; run parallel computing: parallel = T
plot(cv.out)
coefs_lasso <- coef(cv.out, s="lambda.1se") # lambda.min lambda.1se
coefs_lasso <- coef(cv.out, s="lambda.min") # TODO: group variables
data.frame(name = coefs_lasso@Dimnames[[1]][coefs_lasso@i + 1], coefficient = coefs_lasso@x)
selected_variables <- coefs_lasso@i - 1
selected_variables <- selected_variables[selected_variables > 0 & selected_variables <= length(variables_big_regression)]
selected_variables <- variables_big_regression[selected_variables]
selected_variables
summary(glm(as.formula(paste("(taxe_approbation=='Oui') ~", paste(selected_variables, collapse=' + '))), binomial, data=s, weights=s$weight))
prepare_s(exclude_screened=FALSE, exclude_speeder=FALSE, only_finished=T) # TODO: let only_finished = FALSE
sa <- s
# prepare_s(exclude_screened=FALSE, exclude_speeder=FALSE)
# se <- s
# prepare_s(exclude_screened=FALSE)
# sp <- s
prepare_s()
decrit(sa$exclu)
prepare_s <- function(exclude_speeder=TRUE, exclude_screened=TRUE, only_finished=TRUE) { # , exclude_quotas_full=TRUE
# setwd("/home/adrien/Google Drive/Economie/Travail/enquete/codes")
# setwd("C:/Users/a.fabre/Google Drive/Economie/Travail/enquete/codes")
# pes <<- read.csv("fin.csv", sep=";")
# s <<- read.delim("politique.tsv", fileEncoding="UTF-16")
# f_data <- read.delim("fin.tsv", fileEncoding="UTF-16")
s <<- read_csv("survey.csv")
for (i in 1:length(s)) { label(s[[i]]) <<- toString(s[i][[1]][1]) } # Use the first line to create variable names labels then remove it - to run only once
s <<- s[-c(1,2),c(1:91,94:115,117:235,241,247:310,313:319,92,93,116,311,312,236:240,242:246)]
# if (exclude_screened) { s <<- s[s$Q_TerminateFlag=="",] } # remove Screened
# if (exclude_speeder) { s <<- s[n(s$`Duration (in seconds)`) > 540,] } # remove speedest
# if (exclude_quotas_full) { s <<- s[s[101][[1]] %in% c(1:5),]  } # remove those with a problem for the taille d'agglo
# if (exclude_quotas_full) { s <<- s[s$Q_TerminateFlag=="",]  } # remove those with a problem for the taille d'agglo
# if (only_finished) { s <<- s[as.vector(s$Finished)=="True",] }
relabel_and_rename_s()
# s$fini[s$exclu=="QuotaMet"] <<- "False"
if (exclude_screened) { s <<- s[is.na(s$exclu),] } # remove Screened
if (exclude_speeder) { s <<- s[as.numeric(as.vector(s$duree)) > 420,] } # remove speedest /!\ was 540 before 22-02-11:00 (EST Coast time)
# if (exclude_quotas_full) { s <<- s[s[101][[1]] %in% c(1:5),]  } # remove those with a problem for the taille d'agglo
# if (exclude_quotas_full) { s <<- s[s$Q_TerminateFlag=="",]  } # remove those with a problem for the taille d'agglo
if (only_finished) { s <<- s[s$fini=="True",] }
print(paste(length(which(is.na(s$taille_agglo))), "tailles d'agglo sont manquantes"))
s <<- s[!is.na(s$taille_agglo),]
convert_s() # TODO: check the Warnings
s$sample <<- "a"
s$sample[s$fini=="True"] <<- "e"
s$sample[s$fini=="True" & n(s$duree) > 540] <<- "p"
s$sample[s$fini=="True" & n(s$duree) > 540 & s$test_qualite=='Un peu'] <<- "f" # "q"? excluded because out of quotas
s$sample[s$fini=="True" & n(s$duree) > 540 & s$exclu==""] <<- "r"
# s <<- s[-which(is.element(s$id, s$id[duplicated(s$id)]) & !duplicated(s$id)),] # TODO: check duplicates
s$weight <<- weighting_s(s)
}
ss <- s
prepare_s(exclude_screened=FALSE, exclude_speeder=FALSE, only_finished=T) # TODO: let only_finished = FALSE
decrit(s$exclu)
484-599
decrit(s$duree[s$exclu=="QuotaMet"])
decrit(n(s$duree)[s$exclu=="QuotaMet"])
decrit(as.numeric(s$duree)[s$exclu=="QuotaMet"])
length(which(s$duree==0 & s$exclu=="QuotaMet"))
decrit(s$csp[s$exclu=="QuotaMet"])
sss <- s
s <- ss
ss <- sss
rm(sss)
decrit(s$taille_agglo[s$exclu=="QuotaMet"])
decrit(ss$taille_agglo[ss$exclu=="QuotaMet"])
decrit(ss$taille_agglo[ss$exclu=="QuotaMet" & s$csp!="Employé"])
decrit(ss$taille_agglo[ss$exclu=="QuotaMet" & ss$csp!="Employé"])
decrit(ss$sexe[ss$exclu=="QuotaMet" & ss$csp!="Employé"])
decrit(ss$region[ss$exclu=="QuotaMet" & ss$csp!="Employé"])
decrit(ss$diplome[ss$exclu=="QuotaMet" & ss$csp!="Employé"])
decrit(ss$age[ss$exclu=="QuotaMet" & ss$csp!="Employé"])
decrit(ss$duree[ss$exclu=="QuotaMet" & ss$csp!="Employé"])
decrit(ss$duree[ss$exclu=="QuotaMet"])
sort(ss$duree[ss$exclu=="QuotaMet"])
sort(n(ss$duree[ss$exclu=="QuotaMet"])/60)
sort(n(ss$duree[ss$exclu=="QuotaMet"])/3600)
decrit(ss$date[ss$exclu=="QuotaMet" & ss$csp!="Employé"])
2089-115
decrit(s$sexe)
decrit(s$age)
decrit(s$region)
decrit(s$csp)
decrit(s$diplome)
decrit(s$Diplome)
decrit(s$taille_agglo)
decrit(ss$taille_agglo[ss$exclu=="QuotaMet"])
decrit(ss$taille_agglo[ss$exclu=="QuotaMet" & ss$csp=="Employé"])
decrit(ss$date[ss$exclu=="QuotaMet" & ss$csp=="Employé"])
decrit(ss$date[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl(ss$date, "2019-03-04")])
decrit(ss$date[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04", ss$date)])
decrit(ss$date[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 06", ss$date)])
decrit(ss$date[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 07", ss$date)])
decrit(ss$csp[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 07", ss$date)])
decrit(ss$region[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 07", ss$date)])
decrit(ss$taille_agglo[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 07", ss$date)])
decrit(ss$sexe[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 07", ss$date)])
decrit(ss$age[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 07", ss$date)])
decrit(ss$Diplome[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 07", ss$date)])
decrit(ss$diplome4[ss$exclu=="QuotaMet" & ss$csp=="Employé" & !grepl("2019-03-04 07", ss$date)])
1096+995-115
#perform grid search to find optimal value of lambda
#family= binomial => logistic regression, alpha=1 => lasso
# check docs to explore other type.measure options
cv.out <- glmnet(x, y, alpha=1, family="binomial", weights = s$weight, type.multinomial = "grouped") # TODO: how to choose alpha?; run parallel computing: parallel = T
for (v in variables_big_regression) { # display and remove variables with missing values
na_v <- length(which(is.na(s[[v]])))
# if ("labelled" %in% class(s[[v]])) na_v <- length(which(is.na(s[[v]]))) #
# else na_v <- length(which(is.missing(s[[v]])))
if (na_v>0) {
print(paste(v, na_v))
variables_big_regression <- variables_big_regression[variables_big_regression!=v] }
}
x <- model.matrix(as.formula(paste("(taxe_approbation=='Oui') ~", paste(variables_big_regression, collapse=' + '))),  data=s)
y <- ifelse(s$taxe_approbation=="Oui", 1, 0)
#perform grid search to find optimal value of lambda
#family= binomial => logistic regression, alpha=1 => lasso
# check docs to explore other type.measure options
cv.out <- glmnet(x, y, alpha=1, family="binomial", weights = s$weight, type.multinomial = "grouped") # TODO: how to choose alpha?; run parallel computing: parallel = T
plot(cv.out)
coefs_lasso <- coef(cv.out, s="lambda.1se") # lambda.min lambda.1se
#perform grid search to find optimal value of lambda
#family= binomial => logistic regression, alpha=1 => lasso
# check docs to explore other type.measure options
fit <- glmnet(x, y, alpha=1, family="binomial", weights = s$weight, type.multinomial = "grouped")
fit
summary(fit)
cv.out <- cv.glmnet(x, y, alpha=1, family="multinomial", weights = s$weight, type.multinomial = "grouped") # TODO: how to choose alpha?; run parallel computing: parallel = T
plot(cv.out)
coefs_lasso <- coef(cv.out, s="lambda.1se") # lambda.min lambda.1se
coefs_lasso
coefs_lasso <- coef(cv.out, s="lambda.min") # TODO: group variables
coefs_lasso
coefs_lasso <- coef(cv.out, s="lambda.1se") # lambda.min lambda.1se
data.frame(name = coefs_lasso@Dimnames[[1]][coefs_lasso@i + 1], coefficient = coefs_lasso@x)
selected_variables <- coefs_lasso@i - 1
coefs_lasso
cv.out <- cv.glmnet(x, y, alpha=1, family="binomial", weights = s$weight, type.multinomial = "grouped") # TODO: how to choose alpha?; run parallel computing: parallel = T
plot(cv.out)
ols <- summary(lm(as.formula(paste("(taxe_approbation=='Oui') ~", paste(variables_big_regression, collapse=' + '))), data=s))
ols
anova <- summary(aov(as.formula(paste("(taxe_approbation=='Oui') ~", paste(variables_big_regression, collapse=' + '))), data=s))
anova
sum(ols$residuals^2)
anova <- summary(aov(as.formula(paste("(taxe_approbation=='Oui') ~", paste(rev(variables_big_regression), collapse=' + '))), data=s))
anova
