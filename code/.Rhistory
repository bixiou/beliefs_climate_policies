<<<<<<< Updated upstream
<<<<<<< Updated upstream
<<<<<<< HEAD
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, col.axis="red")
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, col.axis="red")
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, col.axis="red")
par(mar = c(2.1, 4.1, 1.6, 0.1), cex=1.5)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport_min <- Ecdf(s$gain_fuel_min)
cdf_transport_max <- Ecdf(s$gain_fuel_max)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, col.axis="red")
par(mar = c(2.1, 4.1, 2.1, 0.1), cex=1.5)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport_min <- Ecdf(s$gain_fuel_min)
cdf_transport_max <- Ecdf(s$gain_fuel_max)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, col.axis="red")
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1, col.axis="red")
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport_min <- Ecdf(s$gain_fuel_min)
cdf_transport_max <- Ecdf(s$gain_fuel_max)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1, col.axis="red")
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red")
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport_min <- Ecdf(s$gain_fuel_min)
cdf_transport_max <- Ecdf(s$gain_fuel_max)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red")
# TODO: finir ça, avec les valeurs de l'?chelle au-dessus
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", labels=c(-190,-110,-70,-40,-15,NA,10,NA,30,NA))
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", labels=c(-190,-110,-70,-40,-15,NA,10,NA,30,NA))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", labels=c(-190,-110,-70,-40,-15,NA,NA,20,30,NA))
cdf_transport_max <- Ecdf(s$gain_fuel_max)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red")
# TODO: finir ça, avec les valeurs de l'?chelle au-dessus
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.8)
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=1)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
# lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
# lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(Ecdf(s$gain_chauffage), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_housing$x, cdf_housing$y, lwd=2, col="blue")
# lines(cdf_housing_min$x, cdf_housing_min$y, type="s", lty=2, col="red")
# lines(cdf_housing_max$x, cdf_housing_max$y, type="s", lty=2, col="red")
axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(Ecdf(s$gain_chauffage), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_housing$x, cdf_housing$y, lwd=2, col="blue")
# lines(cdf_housing_min$x, cdf_housing_min$y, type="s", lty=2, col="red")
# lines(cdf_housing_max$x, cdf_housing_max$y, type="s", lty=2, col="red")
abline(v=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(Ecdf(s$gain), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_all$x, cdf_all$y, lwd=2, col="blue")
# lines(cdf_min$x, cdf_min$y, type="s", lty=2, col="red")
# lines(cdf_max$x, cdf_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-280, -190, -120, -70, -30, 0, 20, 40, 60, 80), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v=c(-280, -190, -120, -70, -30, 0, 20, 40, 60, 80), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-280, -190, -120, -70, -30, 0, 20, 40, 60, 80), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
objective_gains_inelastic <- read.csv2("df_objective_gains_inelastic")
objective_gains_inelastic <- read.csv2("df_objective_gains_inelastic.csv")
objective_gains_inelastic$transport <- n(objective_gains_inelastic$gain_net_numeric_uc_fuel)
objective_gains_inelastic$housing <- n(objective_gains_inelastic$gain_net_numeric_uc_chauffage)
objective_gains_inelastic$all <- n(objective_gains_inelastic$gain_net_numeric_uc_taxe_carbone)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_inelastic$x, cdf_transport_inelastic$y, lwd=2, lty=2, col="blue")
# lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
# lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport_inelastic$x, cdf_transport_inelastic$y, lwd=2, lty=2, col="blue")
cdf_transport_inelastic <- Ecdf(objective_gains_inelastic$transport)
cdf_housing_inelastic <- Ecdf(objective_gains_inelastic$housing)
cdf_all_inelastic <- Ecdf(objective_gains_inelastic$all)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_inelastic$x, cdf_transport_inelastic$y, lwd=2, lty=2, col="blue")
# lines(cdf_transport_min$x, cdf_transport_min$y, type="s", lty=2, col="red")
# lines(cdf_transport_max$x, cdf_transport_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(Ecdf(s$gain_chauffage), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_housing$x, cdf_housing$y, lwd=2, col="blue")
lines(cdf_housing_inelastic$x, cdf_housing_inelastic$y, lwd=2, lty=2, col="blue")
# lines(cdf_housing_min$x, cdf_housing_min$y, type="s", lty=2, col="red")
# lines(cdf_housing_max$x, cdf_housing_max$y, type="s", lty=2, col="red")
abline(v=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(Ecdf(s$gain), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_all$x, cdf_all$y, lwd=2, col="blue")
lines(cdf_all_inelastic$x, cdf_all_inelastic$y, lwd=2, lty=2, col="blue")
# lines(cdf_min$x, cdf_min$y, type="s", lty=2, col="red")
# lines(cdf_max$x, cdf_max$y, type="s", lty=2, col="red")
# axis(1, at=c(-280, -190, -120, -70, -30, 0, 20, 40, 60, 80), tck=0.04, lwd=0, lwd.ticks = 1, col="red", labels=rep("", 10))
abline(v=c(-280, -190, -120, -70, -30, 0, 20, 40, 60, 80), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-280, -190, -120, -70, -30, 0, 20, 40, 60, 80), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
plot(s$simule_gain, jitter(s$gain, 10), xlim=c(-400,300), type='p', col='blue', cex=0.1, xlab='Simulated gain', ylab='Subjective gain')
abline(lm(gain ~ simule_gain, data=s), col='blue', lwd=2)
lines(seq(-500, 500, by=10), seq(-500, 500, by=10), type='l', col='black') + grid()
abline(h = 0, v=0)
cor(s$gain, s$simule_gain) # 0.05
summary(lm(gain ~ simule_gain, data=s))
sum(s$weight[s$simule_gain < s$gain])/sum(s$weight) # 11% surestiment leurs gains
b <- wtd.mean(s$simule_gain - s$gain, weights = s$weight) # 136
# b <- median(s$simule_gain - s$gain) # 161
loess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain-b), data=s)
# plot(s$simule_gain, (s$gagnant_categorie!='Perdant'), col = "red", xlim = c(-500, 300))
plot(sort(s$simule_gain), predict(loess_gains)[order(s$simule_gain)], xlim = c(-500, 300), ylim=c(0,1), type='l', col = "blue", lwd=2)
lines(seq(-500, 300, by=10), predict(loess_gains, newdata = seq(-500, 300, by=10)), type='l', col='red')
grid() # blue: y -> f(y-b) / red: y-b -> f(y-b) (the good one)
f <- function(x, xmin=-500, xmax=300, by=10) approxfun(seq(xmin, xmax, by=by), predict(loess_gains, newdata = seq(xmin, xmax, by=by)), rule=2)(x)
f_inv <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(loess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
ggplot(data=s, aes(simule_gain, 1*(s$gagnant_categorie!='Perdant'))) + ylim(0,1) + xlim(-500, 300) + # xlim(-500, 400) +
xlab("Simulated gain") + ylab("Probability of thinking not to loose") + geom_smooth(method='loess') #  + geom_point()
# why method='auto' yields such a different result?
length(which(s$simule_gain< -500))
length(which(s$simule_gain > 400))
# length(which(s$simule_gain< -500 | s$simule_gain>400)) # 76
decrit(s$gain_echelle)
G_F_by_gain_echelle <- c()
gain_by_gain_echelle <- c()
imax <- 1
for (i in -6:imax) { # différent de confirmation_bias parce que repose sur les catégories de l'échelle, pas sur les quantiles
G_F_by_gain_echelle <- c(G_F_by_gain_echelle, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & pmin(s$gain_echelle, imax)==i])/sum(s$weight[s$variante_taxe_info=='f' & pmin(s$gain_echelle, imax)==i]))
gain_by_gain_echelle <- c(gain_by_gain_echelle, wtd.mean(s$gain[s$variante_taxe_info=='f' & pmin(s$gain_echelle, imax)==i], weights = s$weight[s$variante_taxe_info=='f' & pmin(s$gain_echelle, imax)==i])) }
plot(-6:(-7+length(G_F_by_gain_echelle)), G_F_by_gain_echelle, type='l', xlab='min(gain_echelle, 1)', ylab="Probability that G^F ≠ 'Perdant'") + grid()
hat_g_F_by_gain_echelle <- f_inv(G_F_by_gain_echelle)
hat_alpha_i_by_gain_echelle <- 1 + (gain_by_gain_echelle - hat_g_F_by_gain_echelle)/b
decrit(hat_alpha_i_by_gain_echelle)
confirmation_bias <- function(by_variable = 'gain', nb_bin = 8, local_b = TRUE, return='all', method='median') { # return = c('all', '', 'alpha', 'hat_alpha_i', 'b_i')
nb_bins <- length(levels(binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", ordered=FALSE, weights=s$weight)))
bins <- binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", labels=c(1:nb_bins), ordered=FALSE, weights=s$weight)
gain_i <- G_F_i <- b_i <- G_i <- p_i <- variable_i <- c()
for (i in 1:nb_bins) {
p_i <- c(p_i, sum(s$weight[s$variante_taxe_info=='f' & bins==i])/sum(s$weight[s$variante_taxe_info=='f']))
G_i <- c(G_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
G_F_i <- c(G_F_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
if (method=='median') {
variable_i <- c(variable_i, wtd.median(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weight=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.median(s$gain[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.median((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
} else if (method=='mean') {
variable_i <- c(variable_i, wtd.mean(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weights=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.mean(s$gain[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.mean((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
=======
s$csp[grepl("cadre",s$csp)] <<- "Cadre"
s$csp[grepl("Artisan",s$csp)] <<- "Indépendant"
s$csp[grepl("iaire",s$csp)] <<- "Intermédiaire"
s$csp[grepl("etrait",s$csp)] <<- "Retraité"
s$csp[grepl("Employ",s$csp)] <<- "Employé"
s$csp[grepl("Agricul",s$csp)] <<- "Agriculteur"
s$csp[grepl("Ouvrier",s$csp)] <<- "Ouvrier"
s$csp[grepl("Inactif",s$csp)] <<- "Inactif"
# label(s$csp) <<- lab
# s$csp <<- as.factor(s$csp)
for (i in 1:length(s)) {
# levels(s[[i]]) <<- c(levels(s[[i]]), "NSP")
s[[i]][s[[i]] == "NSP (Ne sais pas, ne se prononce pas)"] <<- "NSP"
s[[i]][s[[i]] == "NSP (Ne sait pas, ne se prononce pas)"] <<- "NSP"
s[[i]][s[[i]] == "NSP (Ne sais pas, ne se prononce pas)."] <<- "NSP"
s[[i]][s[[i]] == "NSP (Ne sait pas, ne se prononce pas)."] <<- "NSP"
s[[i]][s[[i]] == "NSP (Ne sais pas, ne souhaite pas répondre)"] <<- "NSP"
s[[i]][s[[i]] == "NSP (Ne sait pas, ne veut pas répondre)"] <<- "NSP"
s[[i]][s[[i]] == "NSP (Ne veut pas répondre)"] <<- "NSP"
}
s$variante_transferts_inter[!is.na(s$transferts_inter_a) | !is.na(s$transferts_inter_a_info)] <<- "a"
s$transferts_inter <<- NA
s$transferts_inter_info[!is.na(s$transferts_inter_a_info)] <<- TRUE
s$transferts_inter_info[!is.na(s$transferts_inter_a)] <<- FALSE
s$transferts_inter[!is.na(s$transferts_inter_a_info)] <<- s$transferts_inter_a_info[!is.na(s$transferts_inter_a_info)]
s$transferts_inter[!is.na(s$transferts_inter_a)] <<- s$transferts_inter_a[!is.na(s$transferts_inter_a)]
label(s$variante_transferts_inter) <<- "variante_transferts_inter: Variante dans la formulation de transferts_inter; s/i/c/a: simple/intermédiaire/complète/approbation: (argument pauvreté,esponsabilité climatique des pays riches)/complète (i+ argument colonisation, esclavage)/pour ou contre un transfert de 5% des revenus des pays riches vers les pays pauvres (seulement en vague 2); Vague 1: curseur/NSP, Vague 2: champ de saisie (quelques données manquantes) - Q5,Q6,Q78"
label(s$transferts_inter) <<- "transferts_inter: Approbation d'un transfert de 5% des revenus des pays riches vers les pays pauvres"
# s$transferts_inter <<- as.item(as.numeric(s$transferts_inter), missing.values=-1, annotation="transferts_inter: Transferts internationaux, variantes (simple) avec curseur 0-20% (s) ou champ (Quelle % des revenus des pays riches devrait être transférée aux pays pauvres ?) - Q73,91")
s$mauvaise_qualite <<- 0 # 99% if we exclude those from revenu, 92% otherwise
s$mauvaise_qualite[n(s$revenu) > n(s$rev_tot)] <<- 1 + s$mauvaise_qualite[n(s$revenu) > n(s$rev_tot)] # 164
s$mauvaise_qualite[n(s$revenu) > 10000] <<- 1 + s$mauvaise_qualite[n(s$revenu) > 10000] # 58
s$mauvaise_qualite[n(s$rev_tot) > 10000] <<- 1 + s$mauvaise_qualite[n(s$rev_tot) > 10000] # 55
s$revenu <<- clean_number(s$revenu, high_numbers='divide')
s$rev_tot <<- clean_number(s$rev_tot, high_numbers='divide')
for (i in c( # TODO: check number outliers
"revenu", "rev_tot", "taille_menage", "nb_adultes", "nb_14_et_plus", "duree", "variation_aide", "depense_aide", "km_0", "km_1", "km_2", "conso_1", "conso_2", "surface", "emission_cible",
"depense_totale", "depense_sante", "depense_retraites", "depense_protection", "depense_education", "depense_recherche", "depense_loisirs",
"depense_infrastructures", "depense_justice", "depense_armee", "depense_securite", "depense_aide", "variation_totale", "variation_aide",
"variation_sante", "variation_retraites", "variation_protection", "recette_totale", "variation_recette", "budget_equilibre", "regle_or",
"variation_education", "variation_recherche", "variation_loisirs", "variation_infrastructures", "variation_justice", "variation_armee", "variation_securite",
"transports_distance", "duree_info_CC", "duree_info_CC_PM", "duree_info_PM", "duree_no_info", "duree_depenses", "duree_champ_libre",
"hausse_chauffage", "hausse_depenses", "hausse_diesel", "hausse_essence", "nb_vehicules", "en_position_0", "en_position_1", "en_position_2", "en_position_3",
"en_position_4", "en_position_5", "en_position_6", "en_position_7", "en_position_8", "en_position_9", "en_position_10"
)) {
lab <- label(s[[i]])
s[[i]] <<- as.numeric(as.vector(s[[i]]))
label(s[[i]]) <<- lab
>>>>>>> master
}
s$b_i[s$variante_taxe_info=='f' & bins==i] <<- b_i[i] }
plot(1:nb_bins, G_F_i, type='l', xlab=paste('bins of', by_variable, '(lowest to highest)'), ylab="Probability that G^F ≠ 'Perdant'") + grid()
lowess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain - b_i), data=s)
f__1 <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(lowess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
plot(seq(-500, 300, by=10), predict(lowess_gains, newdata = seq(-500, 300, by=10)), xlab=paste('simule_gain - biais_bin(i), où bin vient de', by_variable), ylab='Proba that G != Perdant', type='l', col='red') + grid()
hat_g_F_i <- f__1(G_F_i)
hat_alpha_i <- 1 + (gain_i - hat_g_F_i)/(b_i*local_b + (!local_b)*wtd.mean(s$simule_gain - s$gain, weights = s$weight))
name_by_var <- paste(by_variable, 'i', sep='_')
if (return=='alpha') return(median(hat_alpha_i))
else if (return=='all') return(list('alpha'=median(hat_alpha_i),  name_by_var=variable_i, 'G_i'=G_i, 'gain_i'=gain_i, 'b_i'=b_i ,'G_F_i'=G_F_i, 'hat_g_F_i'=hat_g_F_i, 'hat_alpha_i'=hat_alpha_i)) #
else if (return=='hat_alpha_i') return(hat_alpha_i)
else if (return=='b_i') return(b_i)
else return(list('alpha'=median(hat_alpha_i), 'hat_alpha_i'=hat_alpha_i, 'b_i'=b_i))
}
<<<<<<< HEAD
# preferred specification:
confirmation_bias('simule_gain', 7, TRUE, 'all', 'median')
package("ergm")
plot(s$simule_gain, jitter(s$gain, 10), xlim=c(-400,300), type='p', col='blue', cex=0.1, xlab='Simulated gain', ylab='Subjective gain')
abline(lm(gain ~ simule_gain, data=s), col='blue', lwd=2)
lines(seq(-500, 500, by=10), seq(-500, 500, by=10), type='l', col='black') + grid()
abline(h = 0, v=0)
cor(s$gain, s$simule_gain) # 0.05
summary(lm(gain ~ simule_gain, data=s))
sum(s$weight[s$simule_gain < s$gain])/sum(s$weight) # 11% surestiment leurs gains
b <- wtd.mean(s$simule_gain - s$gain, weights = s$weight) # 136
# b <- median(s$simule_gain - s$gain) # 161
loess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain-b), data=s)
# plot(s$simule_gain, (s$gagnant_categorie!='Perdant'), col = "red", xlim = c(-500, 300))
plot(sort(s$simule_gain), predict(loess_gains)[order(s$simule_gain)], xlim = c(-500, 300), ylim=c(0,1), type='l', col = "blue", lwd=2)
lines(seq(-500, 300, by=10), predict(loess_gains, newdata = seq(-500, 300, by=10)), type='l', col='red')
grid() # blue: y -> f(y-b) / red: y-b -> f(y-b) (the good one)
f <- function(x, xmin=-500, xmax=300, by=10) approxfun(seq(xmin, xmax, by=by), predict(loess_gains, newdata = seq(xmin, xmax, by=by)), rule=2)(x)
f_inv <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(loess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
ggplot(data=s, aes(simule_gain, 1*(s$gagnant_categorie!='Perdant'))) + ylim(0,1) + xlim(-500, 300) + # xlim(-500, 400) +
xlab("Simulated gain") + ylab("Probability of thinking not to loose") + geom_smooth(method='loess') #  + geom_point()
# why method='auto' yields such a different result?
length(which(s$simule_gain< -500))
length(which(s$simule_gain > 400))
# length(which(s$simule_gain< -500 | s$simule_gain>400)) # 76
decrit(s$gain_echelle)
G_F_by_gain_echelle <- c()
gain_by_gain_echelle <- c()
imax <- 1
for (i in -6:imax) { # différent de confirmation_bias parce que repose sur les catégories de l'échelle, pas sur les quantiles
G_F_by_gain_echelle <- c(G_F_by_gain_echelle, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & pmin(s$gain_echelle, imax)==i])/sum(s$weight[s$variante_taxe_info=='f' & pmin(s$gain_echelle, imax)==i]))
gain_by_gain_echelle <- c(gain_by_gain_echelle, wtd.mean(s$gain[s$variante_taxe_info=='f' & pmin(s$gain_echelle, imax)==i], weights = s$weight[s$variante_taxe_info=='f' & pmin(s$gain_echelle, imax)==i])) }
plot(-6:(-7+length(G_F_by_gain_echelle)), G_F_by_gain_echelle, type='l', xlab='min(gain_echelle, 1)', ylab="Probability that G^F ≠ 'Perdant'") + grid()
hat_g_F_by_gain_echelle <- f_inv(G_F_by_gain_echelle)
hat_alpha_i_by_gain_echelle <- 1 + (gain_by_gain_echelle - hat_g_F_by_gain_echelle)/b
decrit(hat_alpha_i_by_gain_echelle)
confirmation_bias <- function(by_variable = 'gain', nb_bin = 8, local_b = TRUE, return='all', method='median') { # return = c('all', '', 'alpha', 'hat_alpha_i', 'b_i')
nb_bins <- length(levels(binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", ordered=FALSE, weights=s$weight)))
bins <- binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", labels=c(1:nb_bins), ordered=FALSE, weights=s$weight)
gain_i <- G_F_i <- b_i <- G_i <- p_i <- variable_i <- c()
for (i in 1:nb_bins) {
p_i <- c(p_i, sum(s$weight[s$variante_taxe_info=='f' & bins==i])/sum(s$weight[s$variante_taxe_info=='f']))
G_i <- c(G_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
G_F_i <- c(G_F_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
if (method=='median') {
variable_i <- c(variable_i, wtd.median(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weight=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.median(s$gain[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.median((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
} else if (method=='mean') {
variable_i <- c(variable_i, wtd.mean(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weights=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.mean(s$gain[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.mean((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
=======
for (j in c("mode_chauffage", "chauffage", "parle_CC", "cause_CC", "effets_CC", "transports_frequence",
"schiste_CC", "transports_avis", "transports_travail_actif", "transports_travail_commun"
# "perte_relative_tva", "perte_relative_fuel", "perte_relative_chauffage", "interet_politique",
)) {
if (j %in% c("mode_chauffage", "chauffage", "schiste_CC", "cause_CC")) s[capitalize(j)] <<- s[j][[1]]
# s[j][[1]] <<- as.item(as.character(s[j][[1]]),
#             labels = structure(levels(factor(s[j][[1]])), names = levels(factor(s[j][[1]]))),
#             missing.values = c("NSP", ""), annotation=paste(attr(s[j][[1]], "label"), "(char)")) # TODO: pb with numbers=T
s[j][[1]] <<- as.item(as.factor(s[j][[1]]),
missing.values = c("NSP", ""), annotation=paste(attr(s[j][[1]], "label"), "(char)")) # TODO: pb with numbers=T
>>>>>>> master
}
s$b_i[s$variante_taxe_info=='f' & bins==i] <<- b_i[i] }
plot(1:nb_bins, G_F_i, type='l', xlab=paste('bins of', by_variable, '(lowest to highest)'), ylab="Probability that G^F ≠ 'Perdant'") + grid()
lowess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain - b_i), data=s)
f__1 <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(lowess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
plot(seq(-500, 300, by=10), predict(lowess_gains, newdata = seq(-500, 300, by=10)), xlab=paste('simule_gain - biais_bin(i), où bin vient de', by_variable), ylab='Proba that G != Perdant', type='l', col='red') + grid()
hat_g_F_i <- f__1(G_F_i)
hat_alpha_i <- 1 + (gain_i - hat_g_F_i)/(b_i*local_b + (!local_b)*wtd.mean(s$simule_gain - s$gain, weights = s$weight))
name_by_var <- paste(by_variable, 'i', sep='_')
if (return=='alpha') return(median(hat_alpha_i))
else if (return=='all') return(list('alpha'=median(hat_alpha_i),  name_by_var=variable_i, 'G_i'=G_i, 'gain_i'=gain_i, 'b_i'=b_i ,'G_F_i'=G_F_i, 'hat_g_F_i'=hat_g_F_i, 'hat_alpha_i'=hat_alpha_i)) #
else if (return=='hat_alpha_i') return(hat_alpha_i)
else if (return=='b_i') return(b_i)
else return(list('alpha'=median(hat_alpha_i), 'hat_alpha_i'=hat_alpha_i, 'b_i'=b_i))
}
# preferred specification:
confirmation_bias('simule_gain', 7, TRUE, 'all', 'median')
confirmation_bias <- function(by_variable = 'gain', nb_bin = 8, local_b = TRUE, return='all', method='median') { # return = c('all', '', 'alpha', 'hat_alpha_i', 'b_i')
nb_bins <- length(levels(binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", ordered=FALSE, weights=s$weight)))
bins <- binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", labels=c(1:nb_bins), ordered=FALSE, weights=s$weight)
gain_i <- G_F_i <- b_i <- G_i <- p_i <- variable_i <- c()
for (i in 1:nb_bins) {
p_i <- c(p_i, sum(s$weight[s$variante_taxe_info=='f' & bins==i])/sum(s$weight[s$variante_taxe_info=='f']))
G_i <- c(G_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
G_F_i <- c(G_F_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
if (method=='median') {
variable_i <- c(variable_i, wtd.median(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weight=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.median(s$gain[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.median((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
} else if (method=='mean') {
variable_i <- c(variable_i, wtd.mean(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weights=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.mean(s$gain[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.mean((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
s$b_i[s$variante_taxe_info=='f' & bins==i] <<- b_i[i] }
plot(1:nb_bins, G_F_i, type='l', xlab=paste('bins of', by_variable, '(lowest to highest)'), ylab="Probability that G^F ≠ 'Perdant'") + grid()
lowess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain - b_i), data=s)
f__1 <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(lowess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
plot(seq(-500, 300, by=10), predict(lowess_gains, newdata = seq(-500, 300, by=10)), xlab=paste('simule_gain - biais_bin(i), où bin vient de', by_variable), ylab='Proba that G != Perdant', type='l', col='red') + grid()
hat_g_F_i <- f__1(G_F_i)
hat_alpha_i <- 1 + (gain_i - hat_g_F_i)/(b_i*local_b + (!local_b)*wtd.mean(s$simule_gain - s$gain, weights = s$weight))
alphas_i <- mean_alphas_i <- median_alphas_i <- c()
for (i in 1:nb_bins) {
alphas_i[s$variante_taxe_info=='f' & bins==i] <- 1 + (s$gain[s$variante_taxe_info=='f' & bins==i] - hat_g_F_i[i])/(b_i[i]*local_b + (!local_b)*(s$simule_gain[s$variante_taxe_info=='f' & bins==i] - s$gain[s$variante_taxe_info=='f' & bins==i]))
mean_alphas_i <- c(mean_alphas_i, wtd.mean(alphas_i[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
median_alphas_i <- c(median_alphas_i, wtd.median(alphas_i[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
name_by_var <- paste(by_variable, 'i', sep='_')
if (return=='alpha') return(median(hat_alpha_i))
else if (return=='all') return(list('alpha'=median(hat_alpha_i),  name_by_var=variable_i, 'G_i'=G_i, 'gain_i'=gain_i,
'b_i'=b_i ,'G_F_i'=G_F_i, 'hat_g_F_i'=hat_g_F_i, 'hat_alpha_i'=hat_alpha_i,
'mean(alphas_i)'=wtd.(alphas_i, weights = s$weight, na.rm=T), 'mean_alphas_i'=mean_alphas_i, 'median_alphas_i'=median_alphas_i)) #
else if (return=='hat_alpha_i') return(hat_alpha_i)
else if (return=='b_i') return(b_i)
else return(list('alpha'=median(hat_alpha_i), 'hat_alpha_i'=hat_alpha_i, 'b_i'=b_i))
}
<<<<<<< HEAD
# preferred specification:
confirmation_bias('simule_gain', 7, TRUE, 'all', 'median')
confirmation_bias <- function(by_variable = 'gain', nb_bin = 8, local_b = TRUE, return='all', method='median') { # return = c('all', '', 'alpha', 'hat_alpha_i', 'b_i')
nb_bins <- length(levels(binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", ordered=FALSE, weights=s$weight)))
bins <- binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", labels=c(1:nb_bins), ordered=FALSE, weights=s$weight)
gain_i <- G_F_i <- b_i <- G_i <- p_i <- variable_i <- c()
for (i in 1:nb_bins) {
p_i <- c(p_i, sum(s$weight[s$variante_taxe_info=='f' & bins==i])/sum(s$weight[s$variante_taxe_info=='f']))
G_i <- c(G_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
G_F_i <- c(G_F_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
if (method=='median') {
variable_i <- c(variable_i, wtd.median(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weight=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.median(s$gain[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.median((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
} else if (method=='mean') {
variable_i <- c(variable_i, wtd.mean(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weights=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.mean(s$gain[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.mean((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
s$b_i[s$variante_taxe_info=='f' & bins==i] <<- b_i[i] }
plot(1:nb_bins, G_F_i, type='l', xlab=paste('bins of', by_variable, '(lowest to highest)'), ylab="Probability that G^F ≠ 'Perdant'") + grid()
lowess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain - b_i), data=s)
f__1 <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(lowess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
plot(seq(-500, 300, by=10), predict(lowess_gains, newdata = seq(-500, 300, by=10)), xlab=paste('simule_gain - biais_bin(i), où bin vient de', by_variable), ylab='Proba that G != Perdant', type='l', col='red') + grid()
hat_g_F_i <- f__1(G_F_i)
hat_alpha_i <- 1 + (gain_i - hat_g_F_i)/(b_i*local_b + (!local_b)*wtd.mean(s$simule_gain - s$gain, weights = s$weight))
alphas_i <- mean_alphas_i <- median_alphas_i <- c()
for (i in 1:nb_bins) {
alphas_i[s$variante_taxe_info=='f' & bins==i] <- 1 + (s$gain[s$variante_taxe_info=='f' & bins==i] - hat_g_F_i[i])/(b_i[i]*local_b + (!local_b)*(s$simule_gain[s$variante_taxe_info=='f' & bins==i] - s$gain[s$variante_taxe_info=='f' & bins==i]))
mean_alphas_i <- c(mean_alphas_i, wtd.mean(alphas_i[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
median_alphas_i <- c(median_alphas_i, wtd.median(alphas_i[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
name_by_var <- paste(by_variable, 'i', sep='_')
if (return=='alpha') return(median(hat_alpha_i))
else if (return=='all') return(list('alpha'=median(hat_alpha_i),  name_by_var=variable_i, 'G_i'=G_i, 'gain_i'=gain_i,
'b_i'=b_i ,'G_F_i'=G_F_i, 'hat_g_F_i'=hat_g_F_i, 'hat_alpha_i'=hat_alpha_i,
'mean(alphas_i)'=wtd.(alphas_i, weights = s$weight, na.rm=T), 'mean_alphas_i'=mean_alphas_i, 'median_alphas_i'=median_alphas_i)) #
else if (return=='hat_alpha_i') return(hat_alpha_i)
else if (return=='b_i') return(b_i)
else return(list('alpha'=median(hat_alpha_i), 'hat_alpha_i'=hat_alpha_i, 'b_i'=b_i))
}
# preferred specification:
confirmation_bias('simule_gain', 7, TRUE, 'all', 'median')
confirmation_bias <- function(by_variable = 'gain', nb_bin = 8, local_b = TRUE, return='all', method='median') { # return = c('all', '', 'alpha', 'hat_alpha_i', 'b_i')
nb_bins <- length(levels(binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", ordered=FALSE, weights=s$weight)))
bins <- binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", labels=c(1:nb_bins), ordered=FALSE, weights=s$weight)
gain_i <- G_F_i <- b_i <- G_i <- p_i <- variable_i <- c()
for (i in 1:nb_bins) {
p_i <- c(p_i, sum(s$weight[s$variante_taxe_info=='f' & bins==i])/sum(s$weight[s$variante_taxe_info=='f']))
G_i <- c(G_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
G_F_i <- c(G_F_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
if (method=='median') {
variable_i <- c(variable_i, wtd.median(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weight=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.median(s$gain[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.median((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
} else if (method=='mean') {
variable_i <- c(variable_i, wtd.mean(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weights=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.mean(s$gain[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.mean((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
=======
temp <- (s$parle_CC=='Plusieurs fois par an') + 2*(s$parle_CC=='Plusieurs fois par mois') - (s$parle_CC=="NSP")
s$parle_CC <<- as.item(temp, labels = structure(c(-1:2),
names = c("NSP","Presque jamais","Plusieurs fois par an","Plusieurs fois par mois")),
missing.values = -1, annotation=Label(s$parle_CC))
temp <- grepl("Faibles", s$effets_CC) + 2*grepl("Graves", s$effets_CC) + 3*grepl("Désastreux", s$effets_CC) + 4*grepl("Cataclysmiques", s$effets_CC) - (s$effets_CC=="NSP")
s$effets_CC <<- as.item(temp, labels = structure(c(-1:4),
names = c("NSP","Insignifiants","Faibles","Graves","Désastreux","Cataclysmiques")),
# names = c("NSP","Insignifiants, voire bénéfiques","Faibles, car les humains sauraient vivre avec","Graves, car il y aurait plus de catastrophes naturelles","Désastreux, les modes de vie seraient largement altérés","Cataclysmiques, l'humanité disparaîtrait")),
missing.values = -1, annotation=Label(s$effets_CC))
temp <- (s$transports_frequence=="Entre quatre fois par jour et une fois par heure") + 2*(s$transports_frequence=="Une ou deux fois par heure") + 3*(s$transports_frequence=="Plus que trois fois par heure") - (s$transports_frequence=="NSP")
s$transports_frequence <<- as.item(temp, labels = structure(c(-1:3),
names = c("NSP","< 3/jour","1/h - 4/jour","1/h - 2/h","> 3/heure")),
# names = c("NSP","Moins de trois fois par jour","Entre quatre fois par jour et une fois par heure","Une ou deux fois par heure","Plus que trois fois par heure")),
missing.values = -1, annotation=Label(s$transports_frequence))
temp <- (s$transports_avis=="Limitée, mais suffisante") + 2*(s$transports_avis=="Convenable, mais devrait être accrue") + 3*(s$transports_avis=="Satisfaisante") - (s$transports_avis=="NSP")
s$transports_avis <<- as.item(temp, labels = structure(c(-1:3),
names = c("NSP","Insuffisante","Limitée","Convenable","Satisfaisante")),
# names = c("NSP","Insuffisante","Limitée, mais suffisante","Convenable, mais devrait être accrue","Satisfaisante")),
missing.values = -1, annotation=Label(s$transports_avis))
labels(s$transports_travail_commun) <<- c("Non"="Non", "NSP"="NSP", "Oui, aucun pb"="Oui, ça ne me poserait pas de grande difficulté", "Oui, embêtant"="Oui, mais ça m'embêterait")
labels(s$transports_travail_actif) <<- c("Non"="Non", "NSP"="NSP", "Oui, aucun pb"="Oui, ça ne me poserait pas de grande difficulté", "Oui, embêtant"="Oui, mais ça m'embêterait")
s$Transports_travail_commun <<- s$transports_travail_commun
s$Transports_travail_actif <<- s$transports_travail_actif
s$Transports_travail_commun[is.na(s$Transports_travail_commun)] <<- "Non concerné"
s$Transports_travail_actif[is.na(s$Transports_travail_actif)] <<- "Non concerné"
s$Transports_travail_actif <<- as.item(as.character(s$Transports_travail_actif), missing.values=c('NSP', "Non concerné"), annotation="Transports_travail_actif: (transports_travail_actif sans NA) Sans changer de logement ni de lieu de travail, il serait possible pour le répondant prenant sa voiture d'effectuer ses trajets domicile-travail en marchant ou en vélo (Non/Oui mais ça l'embêterait/Oui ça ne lui poserait pas de grande difficulté/NSP)")
s$Transports_travail_commun <<- as.item(as.character(s$Transports_travail_commun), missing.values=c('NSP', "Non concerné"), annotation="Transports_travail_commun: (transports_travail_commun sans NA) Sans changer de logement ni de lieu de travail, il serait possible pour le répondant prenant sa voiture de prendre les transports en commun pour ses trajets domicile-travail (Non/Oui mais ça l'embêterait/Oui ça ne lui poserait pas de grande difficulté/NSP)")
s$Transports_distance <<- s$transports_distance
s$Transports_distance[is.na(s$Transports_distance)] <<- mean(s$transports_distance, na.rm=T)
s$Transports_distance <<- as.item(n(s$Transports_distance), missing.values = mean(s$transports_distance, na.rm=T), annotation="Transports_distance: (transports_distance sans NA) L'arrêt de transport en commun le plus proche de chez le répondant est à X minutes de marche")
# TODO: récupérer le vrai âge à partir de ID_age_dep_device.csv
temp <- 20.90*(s$age == "18 à 24 ans") + 29.61*(s$age == "25 à 34 ans") + 42.14*(s$age == "35 à 49 ans") + 56.84*(s$age == "50 à 64 ans") + 75.43*(s$age == "65 ans ou plus")
s$age <<- as.item(temp, labels = structure(c(20.90, 29.61, 42.14, 56.84, 75.43), names = c("18-24", "25-34", "35-49", "50-64", "65+")), annotation=Label(s$age))
# s$Age <<- (s$age == "18 à 24 ans") + 2*(s$age == "25 à 34 ans") + 3.3*(s$age == "35 à 49 ans") + 4.6*(s$age == "50 à 64 ans") + 7*(s$age == "65 ans ou plus")
s$taille_agglo <<- as.item(as.numeric(s$taille_agglo), labels = structure(1:5, names = c("rural", "-20k", "20-100k", "+100k", "Paris")), annotation=Label(s$taille_agglo))
s$Diplome <<- (s$diplome == "Brevet des collèges") + 2*(s$diplome=="CAP ou BEP") + 3*(s$diplome=="Baccalauréat") + 4*(s$diplome=="Bac +2 (BTS, DUT, DEUG, écoles de formation sanitaires et sociales...)") + 5*(s$diplome=="Bac +3 (licence...)") + 6*(s$diplome=="Bac +5 ou plus (master, école d'ingénieur ou de commerce, doctorat, médecine, maîtrise, DEA, DESS...)") - (s$diplome=="NSP (Ne se prononce pas)")
s$diplome4 <<- as.item(pmin(pmax(s$Diplome, 1), 4), labels = structure(1:4, names = c("Aucun diplôme ou brevet", "CAP ou BEP", "Baccalauréat", "Supérieur")), annotation=Label(s$diplome))
# s$diplome4 <<- as.character(s$diplome)
# s$diplome4[s$Diplome<2] <<- "Aucun diplôme ou brevet"
# s$diplome4[s$Diplome>3] <<- "Supérieur"
# labels(s$mode_chauffage) <<- c("individuel"="Chauffage individuel", "collectif"="Chauffage collectif", "NSP"="NSP")
# labels(s$chauffage) <<- c("Gaz réseau"="Gaz de ville", "Gaz bouteille"="Butane, propane, gaz en citerne", "Fioul"="Fioul, mazout, pétrole", "Électricité"="Électricité", "Bois, solaire..."="Bois, solaire, géothermie, aérothermie (pompe à chaleur)", "Autre"="Autre", "NSP"="NSP")
# labels(s$schiste_CC) <<- c("malvenue"="Elle est malvenue : il faudrait mettre fin aux émissions, pas seulement les ralentir", "valable"="Elle est valable : toute baisse des émissions va dans la bonne direction", "NSP"="NSP")
# labels(s$cause_CC) <<- c("n'existe pas"="n'est pas une réalité", "naturel"="est principalement dû à la variabilité naturelle du climat", "anthropique"="est principalement dû à l'activité humaine", "NSP"="NSP")
s$mode_chauffage <<- relabel(s$mode_chauffage, c("Chauffage individuel"="individuel", "Chauffage collectif"="collectif", "NSP"="NSP"))
s$chauffage <<- relabel(s$chauffage, c("Gaz de ville"="Gaz réseau", "Butane, propane, gaz en citerne"="Gaz bouteille", "Fioul, mazout, pétrole"="Fioul", "Électricité"="Électricité", "Bois, solaire, géothermie, aérothermie (pompe à chaleur)"="Bois, solaire...", "Autre"="Autre", "NSP"="NSP"))
s$schiste_CC <<- relabel(s$schiste_CC, c("Elle est malvenue : il faudrait mettre fin aux émissions, pas seulement les ralentir"="malvenue", "Elle est valable : toute baisse des émissions va dans la bonne direction"="valable", "NSP"="NSP"))
s$cause_CC <<- relabel(s$cause_CC, c("n'est pas une réalité"="n'existe pas", "est principalement dû à la variabilité naturelle du climat"="naturel", "est principalement dû à l'activité humaine"="anthropique", "NSP"="NSP"))
s$Compris_depenses <<- as.character(s$compris_depenses)
s$Compris_depenses[is.na(s$Compris_depenses)] <<- "NA"
s$compris_depenses <<- as.item(as.character(s$compris_depenses),
labels = structure(c("", "Oui","Non","Bug: le graphique ne s'est pas affiché correctement."), names = c("NA", "Oui","Non","Bug")), annotation=attr(s$compris_depenses, "label"))
s$enfant_CC[is.na(s$enfant_CC)] <<- "NSP"
s$enfant_CC_pour_CC[s$enfant_CC=='Non'] <<- 'Non concerné'
s$enfant_CC_pour_CC <<- as.item(as.character(s$enfant_CC_pour_CC), labels = structure(c(T, FALSE, 'Non concerné'), names=c('TRUE', 'FALSE', 'Non concerné')),
missing.values='Non concerné', annotation=Label(s$enfant_CC_pour_CC))
s$enfant_CC_pour_lui[s$enfant_CC=='Non'] <<- 'Non concerné'
s$enfant_CC_pour_lui <<- as.item(as.character(s$enfant_CC_pour_lui), labels = structure(c(T, FALSE, 'Non concerné'), names=c('TRUE', 'FALSE', 'Non concerné')),
missing.values='Non concerné', annotation=Label(s$enfant_CC_pour_lui))
s$gauche_droite <<- pmax(-2,pmin(2,-2 * grepl("extrême gauche", s$extr_gauche) - grepl("De gauche", s$gauche) + grepl("De droite", s$droite) + 2 * grepl("extrême droite", s$extr_droite)))
is.na(s$gauche_droite) <<- (s$gauche_droite == 0) & !grepl("centre", s$centre)
s$Gauche_droite <<- as.factor(s$gauche_droite)
s$gauche_droite <<- as.item(as.numeric(as.vector(s$gauche_droite)), labels = structure(c(-2:2),
names = c("Extrême gauche","Gauche","Centre","Droite","Extrême droite")), annotation="gauche_droite:échelle de -2 (extr_gauche) à +2 (extr_droite) - Orientation politique (Comment vous définiriez-vous ? Plusieurs réponses possibles: (D'extrême) gauche/Du centre/(D'extrême) droite/Libéral/Humaniste/Patriote/Apolitique/Écologiste/Conservateur (champ libre)/NSP)")
levels(s$Gauche_droite) <<- c("Extreme-left", "Left", "Center", "Right", "Extreme-right", "Indeterminate")
s$Gauche_droite[is.na(s$Gauche_droite)] <<- "Indeterminate"
temp <- Label(s$interet_politique)
s$interet_politique <<- 1*(s$interet_politique=='Un peu') + 2*(s$interet_politique=='Beaucoup')
s$interet_politique <<- as.item(s$interet_politique, labels=structure(c(0:2), names=c('Presque pas', 'Un peu', 'Beaucoup')), annotation=temp)
# s$gilets_jaunes[s$gilets_jaunes_NSP==T] <<- -99
s$gilets_jaunes[s$gilets_jaunes_compris==T] <<- 0 # total à 115%
s$gilets_jaunes[s$gilets_jaunes_oppose==T] <<- -1 # 2 oppose et soutien en même temps
s$gilets_jaunes[s$gilets_jaunes_soutien==T] <<- 1
s$gilets_jaunes[s$gilets_jaunes_dedans==T] <<- 2
label(s$gilets_jaunes) <<- "gilets_jaunes: -1: s'oppose / 0: comprend sans soutenir ni s'opposer / 1: soutient / 2: fait partie des gilets jaunes (gilets_jaunes_compris/oppose/soutien/dedans/NSP)"
s$gilets_jaunes <<- as.item(n(s$gilets_jaunes), labels = structure(c(-1:2), names=c('oppose', 'comprend', 'soutient', 'est_dedans')),
annotation=attr(s$gilets_jaunes, "label"))
# temp <- label(s$diplome)
# s$diplome <<- factor(s$diplome, c("","Aucun diplôme","Brevet des collèges","CAP ou BEP","Baccalauréat","Bac +2 (BTS, DUT, DEUG, écoles de formation sanitaires et sociales...)","Bac +3 (licence...)","Bac +5 ou plus (master, école d'ingénieur ou de commerce, doctorat, médecine, maîtrise, DEA, DESS...)","NSP (Ne se prononce pas)") )
# label(s$diplome) <<- temp
# temp <- label(s$interet_politique)
# s$interet_politique <<- factor(s$interet_politique, c("","Beaucoup","Un peu","Presque pas (ou pas du tout)","NSP","NSP (Je ne veux pas répondre)","Q20 - À quel point êtes-vous intéressé·e par la politique ?"))
# label(s$interet_politique) <<- temp
s$revenu_conjoint <<- s$rev_tot - s$revenu
s$revdisp <<- round((s$rev_tot -  irpp(s$rev_tot, s$nb_adultes, s$taille_menage)))
s$uc <<- uc(s$taille_menage, s$nb_14_et_plus)
s$niveau_vie <<- s$revdisp / s$uc
# s$age <<- as.factor(as.character(s$age))
# s$Region <<- as.factor(as.character(s$region))
# s$taille_agglo <<- as.factor(gsub("[[:alpha:] ]", "", s$taille_agglo))
# s <<- s[s$taille_agglo!="%1%",]
# pourquoi 91 missing regions? Sûrement un bug du Javascript côté utilisateur (certains types de device/navigateur?): 56% ont un bug sur compris_depenses contre 3% pour les autres
region_code <- function(code) {
reg <- "autre"
regions <- list(
"ARA" = c('01', '03', '07', '15', '26', '38', '42', '43', '63', '69', '73', '74'),
"Est" = c('21', '25', '39', '58', '70', '71', '89', '90', '08', '10', '51', '52', '54', '55', '57', '67', '68', '88'),
"Ouest" = c('22', '29', '35', '56', '14', '27', '50', '61', '76' ),
"Centre" = c('18', '28', '36', '37', '41', '45', '44', '49', '53', '72', '85'),
"Nord" = c('02', '59', '60', '62', '80'),
"IDF" = c('75', '77', '78', '91', '92', '93', '94', '95'),
"SO" = c('16', '17', '19', '23', '24', '33', '40', '47', '64', '79', '86', '87'),
"Occ" = c('09', '11', '12', '30', '31', '32', '34', '46', '48', '65', '66', '81', '82'),
"PACA" = c( '04', '05', '06', '13', '83', '84')
)
for (i in 1:9) if (as.numeric(code) %in% as.numeric(regions[[i]])) reg <- names(regions)[i]
return(reg)
} # TODO: pourquoi Centre excède de 20% le quota? Pourquoi y a-t-il aussi des excès dee quotas dans taille_agglo?
region_dep <- rep("", 95)
for (i in 1:95) region_dep[i] <- region_code(i)
s$region <<- "autre"
s$region[as.numeric(substr(s$code_postal, 1, 2)) %in% 1:95] <<- region_dep[as.numeric(substr(s$code_postal, 1, 2))]
# TODO: missing schiste_traite? dep_traites <- c(01, 02, 04, 06, 07, 08, 10, 11, 12, 13, 24, 25, 26, 30, 31, 32, 33, 34, 38, 39, 40, 45, 46, 48, 51, 54, 55, 57, 59, 60, 62, 64, 65, 67, 68, 69, 71, 73, 74, 77, 78, 82, 83, 84, 89, 90, 91, 93, 94, 95)
s$nb_vehicules <<- (s$nb_vehicules_texte=='Un') + 2*(s$nb_vehicules_texte=='Deux ou plus')
s$variante_partielle <<- 'NA'
s$variante_partielle[!is.na(s$gagnant_chauffage_categorie)] <<- 'c'
s$variante_partielle[!is.na(s$gagnant_fuel_categorie)] <<- 'f'
label(s$variante_partielle) <<- "variante_partielle: Variante aléatoire (c/f) de la taxe partielle sur le chauffage ou les carburants (=fuel)"
s$perte_relative_partielle[s$variante_partielle=='c'] <<- s$perte_relative_chauffage[s$variante_partielle=='c']
s$perte_relative_partielle[s$variante_partielle=='f'] <<- s$perte_relative_fuel[s$variante_partielle=='f']
label(s$perte_relative_partielle) <<- "perte_relative_partielle: Une hausse des taxes sur variante_partielle (chauffage ou fuel) ferait perdre plus à votre ménage que la moyenne (Oui, beaucoup/un peu plus/Autant que la moyenne/Non, un peu/beaucoup moins/NSP) - Q155, 162"
# s$gain_fuel <- NA
s$gain_fuel[s$gagnant_fuel_categorie=='Non affecté' & s$variante_partielle=='f'] <<- 0
s$gain_fuel[s$gagnant_fuel_categorie=='Gagnant' & s$variante_partielle=='f'] <<- 1 + as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_fuel_hausse[s$gagnant_fuel_categorie=='Gagnant' & s$variante_partielle=='f']))))/25
s$gain_fuel[s$gagnant_fuel_categorie=='Perdant' & s$variante_partielle=='f'] <<- - 1 - as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_fuel_baisse[s$gagnant_fuel_categorie=='Perdant' & s$variante_partielle=='f']))))/25
label(s$gain_fuel) <<- "gain_fuel: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe carburants compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40)"
s$gain_chauffage[s$gagnant_chauffage_categorie=='Non affecté' & s$variante_partielle=='c'] <<- 0
s$gain_chauffage[s$gagnant_chauffage_categorie=='Gagnant' & s$variante_partielle=='c'] <<- 1 + as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_chauffage_hausse[s$gagnant_chauffage_categorie=='Gagnant' & s$variante_partielle=='c']))))/25
s$gain_chauffage[s$gagnant_chauffage_categorie=='Perdant' & s$variante_partielle=='c'] <<- - 1 - as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_chauffage_baisse[s$gagnant_chauffage_categorie=='Perdant' & s$variante_partielle=='c']))))/25
label(s$gain_chauffage) <<- "gain_fuel: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe chauffage compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40)"
s$gagnant_partielle_categorie[s$variante_partielle=='c'] <<- s$gagnant_chauffage_categorie[s$variante_partielle=='c']
s$gagnant_partielle_categorie[s$variante_partielle=='f'] <<- s$gagnant_fuel_categorie[s$variante_partielle=='f']
label(s$gagnant_partielle_categorie) <<- "gagnant_partielle_categorie: Ménage Gagnant/Non affecté/Perdant par hausse taxe partielle (chauffage ou fuel) compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40) (gagnant_fuel_categorie/chauffage)"
s$gain_partielle[s$variante_partielle=='c'] <<- s$gain_chauffage[s$variante_partielle=='c']
s$gain_partielle[s$variante_partielle=='f'] <<- s$gain_fuel[s$variante_partielle=='f']
label(s$gain_partielle) <<- "gain_partielle: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe partielle (chauffage ou fuel) compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40) (gain_fuel/chauffage)"
s$gain[s$gagnant_categorie=='Non affecté' & s$variante_partielle!='NA'] <<- 0
s$gain[s$gagnant_categorie=='Gagnant' & s$variante_partielle!='NA'] <<- 1 + as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_hausse[s$gagnant_categorie=='Gagnant' & s$variante_partielle!='NA']))))/50
s$gain[s$gagnant_categorie=='Perdant' & s$variante_partielle!='NA'] <<- - 1 - as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$gain_taxe_baisse[s$gagnant_categorie=='Perdant' & s$variante_partielle!='NA']))))/50
label(s$gain) <<- "gain: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe carbone compensée, dans [-6;5] (seuils: -280/-190/-120/-70/-30/0/20/40/60/80)"
s$gain_echelle <<- s$gain
s$gain_fuel_echelle <<- s$gain_fuel
s$gain_chauffage_echelle <<- s$gain_chauffage
s$gain_partielle_echelle <<- s$gain_fuel
s$gain_partielle_echelle[!is.na(s$gain_chauffage_echelle)] <<- s$gain_chauffage_echelle[!is.na(s$gain_chauffage_echelle)]
label(s$gain) <<- "gain: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe carbone compensée, dans [-6;5] (seuils: -280/-190/-120/-70/-30/0/20/40/60/80)"
label(s$gain_chauffage_echelle) <<- "gain_chauffage_echelle: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe chauffage compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40)"
label(s$gain_fuel_echelle) <<- "gain_fuel_echelle: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe carburants compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40)"
label(s$gain_partielle_echelle) <<- "gain_partielle_echelle: Catégorie de gain-perte de pouvoir d'achat par UC, suite à hausse taxe partielle (carburants ou chauffage) compensée, dans [-6;5] (seuils: -160/-110/-70/-40/-15/0/10/20/30/40)"
# cf. consistency_belief_losses.py pour les imputations
s$gain_min <<- -1000*(s$gain==-6) - 280*(s$gain==-5) - 190*(s$gain==-4) - 120*(s$gain==-3) - 70*(s$gain==-2) - 30*(s$gain==-1) + 0*(s$gain==1) + 20*(s$gain==2) + 40*(s$gain==3) + 60*(s$gain==4) + 80*(s$gain==5)
s$gain_max <<- -280*(s$gain==-6) - 190*(s$gain==-5) - 120*(s$gain==-4) - 70*(s$gain==-3) - 30*(s$gain==-2) - 0*(s$gain==-1) + 20*(s$gain==1) + 40*(s$gain==2) + 60*(s$gain==3) + 80*(s$gain==4) + 2000*(s$gain==5)
s$gain_fuel_min <<- -1000*(s$gain_fuel==-6) - 160*(s$gain_fuel==-5) - 110*(s$gain_fuel==-4) - 70*(s$gain_fuel==-3) - 40*(s$gain_fuel==-2) - 15*(s$gain_fuel==-1) + 0*(s$gain_fuel==1) + 10*(s$gain_fuel==2) + 20*(s$gain_fuel==3) + 30*(s$gain_fuel==4) + 40*(s$gain_fuel==5)
s$gain_fuel_max <<- -160*(s$gain_fuel==-6) - 110*(s$gain_fuel==-5) - 70*(s$gain_fuel==-4) - 40*(s$gain_fuel==-3) - 15*(s$gain_fuel==-2) - 0*(s$gain_fuel==-1) + 10*(s$gain_fuel==1) + 20*(s$gain_fuel==2) + 30*(s$gain_fuel==3) + 40*(s$gain_fuel==4) + 1000*(s$gain_fuel==5)
s$gain_chauffage_min <<- -1000*(s$gain_chauffage==-6) - 160*(s$gain_chauffage==-5) - 110*(s$gain_chauffage==-4) - 70*(s$gain_chauffage==-3) - 40*(s$gain_chauffage==-2) - 15*(s$gain_chauffage==-1) + 0*(s$gain_chauffage==1) + 10*(s$gain_chauffage==2) + 20*(s$gain_chauffage==3) + 30*(s$gain_chauffage==4) + 40*(s$gain_chauffage==5)
s$gain_chauffage_max <<- -160*(s$gain_chauffage==-6) - 110*(s$gain_chauffage==-5) - 70*(s$gain_chauffage==-4) - 40*(s$gain_chauffage==-3) - 15*(s$gain_chauffage==-2) - 0*(s$gain_chauffage==-1) + 10*(s$gain_chauffage==1) + 20*(s$gain_chauffage==2) + 30*(s$gain_chauffage==3) + 40*(s$gain_chauffage==4) + 1000*(s$gain_chauffage==5)
temp <- -405.55*(s$gain==-6) - 224.25*(s$gain==-5) - 147.91*(s$gain==-4) - 92.83*(s$gain==-3) - 48.28*(s$gain==-2) - 13.72*(s$gain==-1) + 10.39*(s$gain==1) + 30.36*(s$gain==2) + 49.96*(s$gain==3) + 69.72*(s$gain==4) + 106.89*(s$gain==5) #  - 1.66*(s$gain==0)
s$gain <<- as.item(temp, labels = structure(c(-405.55, -224.25, -147.91, -92.83, -48.28, -13.72, 0, 10.39, 30.36, 49.96, 69.72, 106.89), names = c("<-280", "-280_-190", "-190_-120", "-120_-70", "-70_-30", "-30_0", "0", "0_20", "20_40", "40_60", "60_80", ">80")), annotation=Label(s$gain))
temp <- NA
temp[!is.na(s$gain_fuel)] <- (-248.76*(s$gain_fuel==-6) - 131.21*(s$gain_fuel==-5) - 87.36*(s$gain_fuel==-4) - 53.27*(s$gain_fuel==-3) - 25.49*(s$gain_fuel==-2) - 7.51*(s$gain_fuel==-1) + 5.17*(s$gain_fuel==1) + 14.73*(s$gain_fuel==2) + 24.85*(s$gain_fuel==3) + 34.89*(s$gain_fuel==4) + 57.42*(s$gain_fuel==5))[!is.na(s$gain_fuel)] #  - 1.17*(s$gain_fuel==0)
s$gain_fuel <<- as.item(temp, labels = structure(c(-248.76, -131.21, -87.36, -53.27, -25.49, -7.51, 0, 5.17, 14.73, 24.85, 34.89, 57.42), names = c("<-160", "-160_-110", "-110_-70", "-70_-40", "-40_-15", "-15_0", "0", "0_10", "10_20", "20_30", "30_40", ">40")), annotation=Label(s$gain_fuel))
temp <- NA
temp[!is.na(s$gain_chauffage)] <- (-262.07*(s$gain_chauffage==-6) - 132.69*(s$gain_chauffage==-5) - 87.05*(s$gain_chauffage==-4) - 53.65*(s$gain_chauffage==-3) - 26.57*(s$gain_chauffage==-2) - 7.20*(s$gain_chauffage==-1) + 4.53*(s$gain_chauffage==1) + 15.44*(s$gain_chauffage==2) + 25.26*(s$gain_chauffage==3) + 35.66*(s$gain_chauffage==4) + 54.67*(s$gain_chauffage==5))[!is.na(s$gain_chauffage)] #  - 1.34*(s$gain_chauffage==0)
s$gain_chauffage <<- as.item(temp, labels = structure(c(-262.07, -132.69, -87.05, -53.65, -26.57, -7.20, 0, 4.53, 15.44, 25.26, 35.66, 54.67), names = c("<-160", "-160_-110", "-110_-70", "-70_-40", "-40_-15", "-15_0", "0", "0_10", "10_20", "20_30", "30_40", ">40")), annotation=Label(s$gain_chauffage))
s$Elasticite_chauffage <<- as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$elasticite_chauffage))))
s$Elasticite_chauffage <<- (s$Elasticite_chauffage==0)*1.5 + (s$Elasticite_chauffage==3)*6.5 + (s$Elasticite_chauffage>3)*(s$Elasticite_chauffage + 5) # Take the average of thresholds, take 40% for >30%
s$Elasticite_chauffage <<- - round(s$Elasticite_chauffage / 30, 2) # converts into elasticity
label(s$Elasticite_chauffage) <<- "Elasticite_chauffage: Élasticité-prix des dépenses de chauffage des Français, calculée en prenant la valeur moyenne des intervalles proposées (seuils à 0/3/10/20/30% pour une hausse de 30%)"
s$Elasticite_chauffage_perso <<- as.numeric(sub(".*\\s(\\d*)%\\s.*", "\\1", s$elasticite_chauffage_perso))
s$Elasticite_chauffage_perso <<- ifelse(s$variante_partielle=='f', NA, ifelse(is.na(s$Elasticite_chauffage_perso), 0, s$Elasticite_chauffage_perso+5*(1+1*(s$Elasticite_chauffage_perso==30)))) # Take the average of thresholds, take 40% for >30%
s$Elasticite_chauffage_perso <<- - round(s$Elasticite_chauffage_perso / 30, 2) # converts into elasticity
label(s$Elasticite_chauffage_perso) <<- "Elasticite_chauffage_perso: Élasticité-prix des dépenses de chauffage du ménage, calculée en prenant la valeur moyenne des intervalles proposées (seuils à 0/3/10/20/30% pour une hausse de 30%)"
s$Elasticite_fuel <<- as.numeric(gsub("\\D*", "", sub("\\sà.*", "", sub("\\D*", "", s$elasticite_fuel))))
s$Elasticite_fuel <<- (s$Elasticite_fuel==0)*1.5 + (s$Elasticite_fuel==3)*6.5 + (s$Elasticite_fuel>3)*(s$Elasticite_fuel + 5) # Take the average of thresholds, take 40% for >30%
s$Elasticite_fuel <<- - round(s$Elasticite_fuel / 30, 2) # converts into elasticity
label(s$Elasticite_fuel) <<- "Elasticite_fuel: Élasticité-prix des dépenses de carburants des Français, calculée en prenant la valeur moyenne des intervalles proposées (seuils à 0/3/10/20/30% pour une hausse de 0.5€/L)"
s$Elasticite_fuel_perso <<- as.numeric(sub(".*\\s(\\d*)%\\s.*", "\\1", s$elasticite_fuel_perso))
s$Elasticite_fuel_perso <<- ifelse(s$variante_partielle=='c', NA, ifelse(is.na(s$Elasticite_fuel_perso), 0, s$Elasticite_fuel_perso+5*(1+1*(s$Elasticite_fuel_perso==30)))) # Take the average of thresholds, take 40% for >30%
s$Elasticite_fuel_perso <<- - round(s$Elasticite_fuel_perso / 30, 2) # converts into elasticity
label(s$Elasticite_fuel_perso) <<- "Elasticite_fuel_perso: Élasticité-prix des dépenses de carburants du ménage, calculée en prenant la valeur moyenne des intervalles proposées (seuils à 0/3/10/20/30% pour une hausse de 0.5€/L)"
s$elasticite_partielle <<- s$elasticite_chauffage
s$elasticite_partielle[!is.na(s$elasticite_fuel)] <<- s$elasticite_fuel[!is.na(s$elasticite_fuel)]
label(s$elasticite_partielle) <<- "elasticite_partielle: Réduction de la conso de fioul et gaz OU de carburants des Français suite à augmentation du prix de 30% (0% - Je n'en consomme déjà presque pas/0% - Je suis contraint sur tous mes déplacements/de 0% à 10%/de 10% à 20%/de 20% à 30%/+ de 30% - Je changerais largement mes habitudes de déplacement)"
s$Elasticite_partielle <<- s$Elasticite_chauffage
s$Elasticite_partielle[!is.na(s$Elasticite_fuel)] <<- s$Elasticite_fuel[!is.na(s$Elasticite_fuel)]
label(s$Elasticite_partielle) <<- "Elasticite_partielle: Élasticité-prix des dépenses de fioul et gaz OU de carburants des Français, calculée en prenant la valeur moyenne des intervalles proposées"
s$elasticite_partielle_perso <<- s$elasticite_chauffage_perso
s$elasticite_partielle_perso[!is.na(s$elasticite_fuel_perso)] <<- s$elasticite_fuel_perso[!is.na(s$elasticite_fuel_perso)]
label(s$elasticite_partielle_perso) <<- "elasticite_partielle_perso: Réduction de la conso de fioul et gaz OU de carburants du ménage suite à augmentation du prix de 30% (0% - Je n'en consomme déjà presque pas/0% - Je suis contraint sur tous mes déplacements/de 0% à 10%/de 10% à 20%/de 20% à 30%/+ de 30% - Je changerais largement mes habitudes de déplacement)"
s$Elasticite_partielle_perso <<- s$Elasticite_chauffage_perso
s$Elasticite_partielle_perso[!is.na(s$Elasticite_fuel_perso)] <<- s$Elasticite_fuel_perso[!is.na(s$Elasticite_fuel_perso)]
label(s$Elasticite_partielle_perso) <<- "Elasticite_partielle_perso: Élasticité-prix des dépenses de fioul et gaz OU de carburants du ménage, calculée en prenant la valeur moyenne des intervalles proposées"
s$variante_taxe_info <<- "p"
s$variante_taxe_info[s$gagnant_feedback_categorie!=""] <<- "f"
label(s$variante_taxe_info) <<- "variante_taxe_info: (f/p) Variante aléatoire entre f: feedback (=simulation, 2/3) et p: progressivité (1/3), dans l'information donnée sur la taxe compensée avant de demander à nouveau le gain et l'approbation, ainsi que les bénéfices et problèmes"
s$nb_benefices <<- 0
s$nb_problemes <<- 0
for (v in c('CC', 'sante', 'circulation', 'revenu', 'pauvres', 'independance', 'enjeu', 'aucun', 'autre_choix', 'autre')) {
s[[paste('benefices_', v, sep="")]] <<- s[paste('benefices_', v, '_p', sep="")][[1]]
s[[paste('benefices_', v, sep="")]][s$variante_taxe_info=='f'] <<- s[paste('benefices_', v, '_f', sep="")][[1]][s$variante_taxe_info=='f']
if (!(v %in% c('aucun', 'autre'))) s$nb_problemes <<- s$nb_problemes + 1*(s[[paste('benefices_', v, sep="")]]==T)
label(s[[paste('benefices_', v, sep="")]]) <<- sub("_f: \\* ", ": ", label(s[paste('benefices_', v, '_f', sep="")][[1]]))
}
for (v in c('inefficace', 'alternatives', 'ruraux', 'revenu', 'pauvres', 'economie', 'pretexte', 'aucun', 'autre_choix', 'autre')) {
s[[paste('problemes_', v, sep="")]] <<- s[paste('problemes_', v, '_p', sep="")][[1]]
s[[paste('problemes_', v, sep="")]][s$variante_taxe_info=='f'] <<- s[paste('problemes_', v, '_f', sep="")][[1]][s$variante_taxe_info=='f']
if (!(v %in% c('aucun', 'autre'))) s$nb_problemes <<- s$nb_problemes + 1*(s[[paste('problemes_', v, sep="")]]==T)
label(s[[paste('problemes_', v, sep="")]]) <<- sub("_f: \\* ", ": ", label(s[paste('problemes_', v, '_f', sep="")][[1]]))
}
label(s$nb_benefices) <<- "nb_benefices: Nombre de bénéfices d'une taxe carbone compensée cochés par le répondant, dans [0;8]"
label(s$nb_problemes) <<- "nb_problemes: Nombre de problèmes d'une taxe carbone compensée cochés par le répondant, dans [0;8]"
s$gagnant_info_categorie <<- s$gagnant_feedback_categorie
s$gagnant_info_categorie[!is.na(s$gagnant_progressif_categorie)] <<- s$gagnant_progressif_categorie[!is.na(s$gagnant_progressif_categorie)]
label(s$gagnant_info_categorie) <<- "gagnant_info_categorie: après info simule_gagnant et/ou progressivité: Ménage Gagnant/Non affecté/Perdant par hausse taxe carbone redistribuée à tous (+110€/an /adulte, +13/15% gaz/fioul, +0.11/13 €/L diesel/essence)"
s$taxe_info_approbation <<- s$taxe_feedback_approbation
s$taxe_info_approbation[!is.na(s$taxe_progressif_approbation)] <<- s$taxe_progressif_approbation[!is.na(s$taxe_progressif_approbation)]
annotation(s$taxe_info_approbation) <<- "taxe_info_approbation: après info simule_gagnant et/ou progressivité - Approbation d'une hausse de la taxe carbone compensée (+110€/an /adulte, +13/15% gaz/fioul, +0.11/13 €/L diesel/essence)"
s$cible[s$cible20==1] <<- '20'
s$cible[s$cible30==1] <<- '30'
s$cible[s$cible40==1] <<- '40'
s$cible[s$cible50==1] <<- '50'
s$cible <<- relevel(as.factor(s$cible), '50')
label(s$cible) <<- "cible: Ciblage du recyclage de la hausse de la taxe carbone, attribué en fonction du revenu du répondant et de son ménage (20/30/40/50% les plus modestes)"
# TODO: manage to use tidyverse without erasing observations
# s <<- merge(s, s %>% gather(key = temp, value = gain_cible, c(gagnant__20_categorie, gagnant_20_30_categorie, gagnant_30_40_categorie, gagnant_40_50_categorie, gagnant_50_70_categorie, gagnant_70__categorie)) %>% filter(gain_cible != "") %>% select(-temp), sort=FALSE) # Warning: attributes are not identical across measure variables; they will be dropped
# label(s$gain_cible) <<- "gain_cible: Ménage Gagnant/Non affecté/Perdant avec hausse taxe carbone à recyclage ciblé (cible: 20/30/40/50% les plus modestes)"
# s <<- merge(s, s %>% gather(key = temp, value = taxe_cible_approbation, c(taxe__20_approbation, taxe_20_30_approbation, taxe_30_40_approbation, taxe_40_50_approbation, taxe_50_70_approbation, taxe_70__approbation)) %>% filter(taxe_cible_approbation != "") %>% select(-temp), sort=FALSE)
# label(s$taxe_cible_approbation) <<- "taxe_cible_approbation: Approbation d'une hausse de la taxe carbone compensée par recyclage ciblé (cible: 20/30/40/50% les plus modestes)"
#
#   # s <<- s %>% gather(key = temp, value = km, c(km_0, km_1, km_2)) %>% filter(km != "") %>% select(-temp) # erases km_0, km_1, km_2
# s <<- merge(s, s %>% gather(key = temp, value = km, c(km_0, km_1, km_2)) %>% filter(km != "") %>% select(-temp), sort=FALSE) # Warning: attributes are not identical across measure variables; they will be dropped
# label(s$km) <<- "km: Nombre de kilomètres parcourus lors des 12 derniers mois en voiture ou moto (par le répondant pour nb_vehicules=0, par les véhicules sinon)"
#
# s <<- merge(s, s %>% gather(key = temp, value = conso, c(conso_1, conso_2)) %>% filter(conso != "") %>% select(-temp), sort=FALSE)
# label(s$conso) <<- "conso:  Consommation moyenne du véhicule (en litres aux 100 km)"
s$gagnant_cible_categorie[!is.na(s$gagnant__20_categorie)] <<- s$gagnant__20_categorie[!is.na(s$gagnant__20_categorie)]
s$gagnant_cible_categorie[!is.na(s$gagnant_20_30_categorie)] <<- s$gagnant_20_30_categorie[!is.na(s$gagnant_20_30_categorie)]
s$gagnant_cible_categorie[!is.na(s$gagnant_30_40_categorie)] <<- s$gagnant_30_40_categorie[!is.na(s$gagnant_30_40_categorie)]
s$gagnant_cible_categorie[!is.na(s$gagnant_40_50_categorie)] <<- s$gagnant_40_50_categorie[!is.na(s$gagnant_40_50_categorie)]
s$gagnant_cible_categorie[!is.na(s$gagnant_50_70_categorie)] <<- s$gagnant_50_70_categorie[!is.na(s$gagnant_50_70_categorie)]
s$gagnant_cible_categorie[!is.na(s$gagnant_70__categorie)] <<- s$gagnant_70__categorie[!is.na(s$gagnant_70__categorie)]
label(s$gagnant_cible_categorie) <<- "gagnant_cible_categorie: Ménage Gagnant/Non affecté/Perdant avec hausse taxe carbone à recyclage ciblé (cible: 20/30/40/50% les plus modestes)"
s$taxe_cible_approbation[!is.na(s$taxe__20_approbation)] <<- s$taxe__20_approbation[!is.na(s$taxe__20_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_20_30_approbation)] <<- s$taxe_20_30_approbation[!is.na(s$taxe_20_30_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_30_40_approbation)] <<- s$taxe_30_40_approbation[!is.na(s$taxe_30_40_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_40_50_approbation)] <<- s$taxe_40_50_approbation[!is.na(s$taxe_40_50_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_50_70_approbation)] <<- s$taxe_50_70_approbation[!is.na(s$taxe_50_70_approbation)]
s$taxe_cible_approbation[!is.na(s$taxe_70__approbation)] <<- s$taxe_70__approbation[!is.na(s$taxe_70__approbation)]
label(s$taxe_cible_approbation) <<- "taxe_cible_approbation: Approbation d'une hausse de la taxe carbone compensée par recyclage ciblé (cible: 20/30/40/50% les plus modestes)"
s$categorie_cible[!is.na(s$taxe__20_approbation)] <<- '_20'
s$categorie_cible[!is.na(s$taxe_20_30_approbation)] <<- '20_30'
s$categorie_cible[!is.na(s$taxe_30_40_approbation)] <<- '30_40'
s$categorie_cible[!is.na(s$taxe_40_50_approbation)] <<- '40_50'
s$categorie_cible[!is.na(s$taxe_50_70_approbation)] <<- '50_70'
s$categorie_cible[!is.na(s$taxe_70__approbation)] <<- '70_'
label(s$categorie_cible) <<- "categorie_cible: Catégorie de revenu du répondant (et de son ménage) taxe à recyclage ciblé - Catégories: percentile <20/20-30/30-40/40-50/50-70/>70, sachant que revenu_conjoint détermine la catégorie quand percentile de revenu > 70 (780/1140/1430/1670/2220)"
s$traite_cible <<- (s$cible==20)*(s$revenu<780) + (s$cible==30)*(s$revenu<1140) + (s$cible==40)*(s$revenu<1430) + (s$cible==50)*(s$revenu<1670)
s$traite_cible_conjoint <<- (s$nb_adultes > 1)* ((s$cible==20)*(s$revenu_conjoint<780) + (s$cible==30)*(s$revenu_conjoint<1140) + (s$cible==40)*(s$revenu_conjoint<1430) + (s$cible==50)*(s$revenu_conjoint<1670))
label(s$traite_cible) <<- "traite_cible: Indicatrice de transfert reçu par le répondant lors de la hausse de la taxe carbone avec compensation ciblée. Montants: 550/360/270/220 €/an/adulte pour cible à 20/30/40/50"
label(s$traite_cible_conjoint) <<- "traite_cible_conjoint: Indicatrice de transfert reçu par le conjoint du répondant lors de la hausse de la taxe carbone avec compensation ciblée. Montants: 550/360/270/220 €/an/adulte pour cible à 20/30/40/50"
s$versement_cible <<- (s$traite_cible + s$traite_cible_conjoint) * ((s$cible==20)*550 + (s$cible==30)*360 + (s$cible==40)*270 + (s$cible==50)*220)
s$versement_cible_sans_conjoint <<- (s$traite_cible) * ((s$cible==20)*550 + (s$cible==30)*360 + (s$cible==40)*270 + (s$cible==50)*220)
label(s$versement_cible) <<- "versement_cible: Versement annuel reçu par le ménage du répondant lors de la hausse de la taxe carbone avec compensation ciblée. Montants: 550/360/270/220 €/an/parent pour cible à 20/30/40/50"
label(s$versement_cible_sans_conjoint) <<- "versement_cible_sans_conjoint: Versement annuel reçu par le répondant lors de la hausse de la taxe carbone avec compensation ciblée. Montants: 550/360/270/220 €/an/adulte pour cible à 20/30/40/50"
s$versement <<- 110 * s$nb_adultes
label(s$versement) <<- "versement: Versement annuel reçu par le ménage suite à une hausse de la taxe carbone compensée (110 * nb_adultes)"
s$km[!is.na(s$km_0)] <<- s$km_0[!is.na(s$km_0)]
s$km[!is.na(s$km_1)] <<- s$km_1[!is.na(s$km_1)]
s$km[!is.na(s$km_2)] <<- s$km_2[!is.na(s$km_2)]
label(s$km) <<- "km: Nombre de kilomètres parcourus lors des 12 derniers mois en voiture ou moto (par le répondant pour nb_vehicules=0, par les véhicules sinon)"
s$conso[!is.na(s$conso_1)] <<- s$conso_1[!is.na(s$conso_1)]
s$conso[!is.na(s$conso_2)] <<- s$conso_2[!is.na(s$conso_2)]
s$conso[is.na(s$conso)] <<- (6.39 + 7.31) / 2
label(s$conso) <<- "conso:  Consommation moyenne du véhicule (en litres aux 100 km)"
s$gaz <<- grepl('gaz', s$chauffage, ignore.case = T)
s$fioul <<- grepl('fioul', s$chauffage, ignore.case = T)
s$hausse_chauffage <<- -55.507189 + s$gaz * 124.578484 + s$fioul * 221.145441 + s$surface * 0.652174
s$hausse_diesel[s$nb_vehicules == 0] <<- (0.5*(6.39/100) * s$km * 1.4 * (1 - 0.4) * 0.090922)[s$nb_vehicules == 0] # share_diesel * conso * km * price * (1-elasticite) * price_increase
s$hausse_diesel[s$nb_vehicules == 1] <<- ((s$fuel_1=='Diesel') * (s$conso/100) * s$km * 1.4 * (1 - 0.4) * 0.090922)[s$nb_vehicules == 1]
s$hausse_diesel[s$nb_vehicules == 2] <<- (((s$fuel_2_1=='Diesel')*2/3 + (s$fuel_2_2=='Diesel')/3) * (s$conso/100) * s$km * 1.4 * (1 - 0.4) * 0.090922)[s$nb_vehicules == 2]
s$hausse_essence[s$nb_vehicules == 0] <<- (0.5*(7.31/100) * s$km * 1.45 * (1 - 0.4) * 0.076128)[s$nb_vehicules == 0] # share_diesel * conso * km * price * (1-elasticite) * price_increase
s$hausse_essence[s$nb_vehicules == 1] <<- ((s$fuel_1!='Diesel') * (s$conso/100) * s$km * 1.45 * (1 - 0.4) * 0.076128)[s$nb_vehicules == 1]
s$hausse_essence[s$nb_vehicules == 2] <<- (((s$fuel_2_1!='Diesel')*2/3 + (s$fuel_2_2!='Diesel')/3) * (s$conso/100) * s$km * 1.45 * (1 - 0.4) * 0.076128)[s$nb_vehicules == 2]
s$hausse_carburants <<- s$hausse_diesel + s$hausse_essence
s$depense_carburants <<- (s$hausse_diesel / 0.090922 + s$hausse_essence / 0.076128) / (1 - 0.4)
label(s$hausse_carburants) <<- "hausse_carburant: Hausse des dépenses de carburants simulées pour le ménage, suite à la taxe (élasticité de 0.4) (hausse_diesel + hausse_essence)"
label(s$depense_carburants) <<- "depense_carburants: Dépense de carburants annuelle estimée du ménage, avant la réforme"
s$hausse_depenses <<- s$hausse_carburants + s$hausse_chauffage
s$diesel <<- (!is.na(s$fuel_1) & (s$fuel_1=='Diesel')) | (!is.na(s$fuel_2_2) & ((s$fuel_2_1=='Diesel') | (s$fuel_2_2=='Diesel')))
s$essence <<- (!is.na(s$fuel_1) & (s$fuel_1=='Essence')) | (!is.na(s$fuel_2_2) & ((s$fuel_2_1=='Essence') | (s$fuel_2_2=='Essence')))
label(s$diesel) <<- "diesel: Indicatrice de la possession d'un véhicule diesel par le ménage (fuel_1 ou fuel_2_1 ou fuel_2_2 = 'Diesel')"
label(s$essence) <<- "essence: Indicatrice de la possession d'un véhicule à essence par le ménage (fuel_1 ou fuel_2_1 ou fuel_2_2 = 'Essence')"
s$simule_gain <<- 16.1 + s$nb_adultes * 110 - s$hausse_depenses # élasticité de 0.15 sur le gaz
s$simule_gain_repondant <<- 16.1 + 110 - s$hausse_depenses
label(s$simule_gain) <<- "simule_gain: Gain net annuel simulé pour le ménage du répondant suite à une hausse de taxe carbone compensée: 16.1 + nb_adultes * 110 - hausse_depenses"
label(s$simule_gain_repondant) <<- "simule_gain_repondant: Gain net annuel simulé pour le répondant (sans tenir compte du potentiel versement reçu par les autres adultes du ménage) suite à une hausse de taxe carbone compensée: 116.1 - hausse_depenses"
s$simule_gain_cible <<- s$versement_cible - s$hausse_depenses
s$simule_gain_cible_sans_conjoint <<- s$versement_cible - s$hausse_depenses
label(s$simule_gain_cible) <<- "simule_gain_cible: Gain net simulé pour le ménage du répondant suite à une hausse de taxe carbone avec compensation ciblée: versement_cible - hausse_depenses"
label(s$simule_gain_cible_sans_conjoint) <<- "simule_gain_cible_sans_conjoint: Gain net simulé pour le répondant (sans tenir compte du potentiel versement reçu par son conjoint) suite à une hausse de taxe carbone avec compensation ciblée: versement_cible - hausse_depenses"
s$simule_gagnant[is.na(s$simule_gagnant)] <<- 1*(s$simule_gain[is.na(s$simule_gagnant)] > 0)
s$hausse_chauffage_interaction_inelastique <<- 152.6786*s$fioul + s$surface * (1.6765*s$gaz + 1.1116*s$fioul)
s$depense_chauffage <<- ((1*(s$fioul) * (152.6786 + 1.1116*s$surface)) / 0.148079 + 1.6765*s$gaz*s$surface / 0.133456)
s$simule_gain_interaction <<- 9.1 + s$nb_adultes * 110 - s$hausse_carburants - s$hausse_chauffage_interaction_inelastique * (1 - 0.2) # élasticité de 0.2 pour le gaz
s$simule_gagnant_interaction <<- 1*(s$simule_gain_interaction > 0)
s$simule_gain_inelastique <<- s$nb_adultes * 110 - s$hausse_carburants/(1 - 0.4) - s$hausse_chauffage_interaction_inelastique # élasticité nulle. Inclure + 22.4 rendrait le taux d'erreur uniforme suivant les deux catégories, on ne le fait pas pour être volontairement conservateur
s$simule_gain_elast_perso[s$variante_partielle=='c'] <<- s$nb_adultes[s$variante_partielle=='c'] * 110 - (s$hausse_chauffage_interaction_inelastique[s$variante_partielle=='c'] * (1 + s$Elasticite_chauffage_perso[s$variante_partielle=='c']) + s$hausse_carburants)
s$simule_gain_elast_perso[s$variante_partielle=='f'] <<- s$nb_adultes[s$variante_partielle=='f'] * 110 - (s$hausse_carburants[s$variante_partielle=='f'] * (1 + s$Elasticite_fuel_perso[s$variante_partielle=='f']) / (1 - 0.4) + s$hausse_chauffage_interaction_inelastique * (1 - 0.2))
label(s$hausse_chauffage_interaction_inelastique) <<- "hausse_chauffage_interaction_inelastique: Hausse des dépenses de chauffage simulées pour le ménage avec des termes d'interaction entre surface et gaz/fioul plutôt que sans, suite à la taxe (élasticité nulle)"
label(s$depense_chauffage) <<- "depense_chauffage: Dépense de chauffage annuelle estimée du ménage, avant la réforme"
label(s$simule_gain_interaction) <<- "simule_gain_interaction: Gain net annuel simulé avec des termes d'interaction surface*fioul/gaz pour le ménage du répondant suite à une hausse de taxe carbone compensée: 9.1 + nb_adultes * 110 - hausse_chauffage_interaction_inelastique * 0.8 - hausse_carburants"
label(s$simule_gagnant_interaction) <<- "simule_gagnant_interaction: Indicatrice sur la prédiction que le ménage serait gagnant avec la taxe compensée, d'après nos simulations avec des termes d'interaction surface*fioul/gaz: 1*(simule_gain_interaction > 0)"
label(s$simule_gain_inelastique) <<- "simule_gain_inelastique: Gain net annuel simulé (avec interaction) avec une élasticité nulle, pour le ménage du répondant suite à une hausse de taxe carbone compensée:  nb_adultes * 110 - hausse_chauffage_interaction_inelastique - hausse_carburants / 0.6"
label(s$simule_gain_elast_perso) <<- "simule_gain_elast_perso: Gain net annuel simulé (avec interaction) avec l'élasticité renseignée par le répondant, pour le ménage du répondant suite à une hausse de taxe carbone compensée: nb_adultes * 110 - hausse_partielle_inelastique * (1 - Elasticite_partielle_perso) - hausse_autre_partielle"
s$progressivite[!is.na(s$progressivite_feedback_sans_info)] <<- s$progressivite_feedback_sans_info[!is.na(s$progressivite_feedback_sans_info)]
s$progressivite[!is.na(s$progressivite_feedback_avec_info)] <<- s$progressivite_feedback_avec_info[!is.na(s$progressivite_feedback_avec_info)]
s$progressivite[!is.na(s$progressivite_progressif)] <<- s$progressivite_progressif[!is.na(s$progressivite_progressif)]
label(s$progressivite) <<- "progressivite: ~ Une hausse de la taxe carbone compensée avantagerait les plus modestes (réunion des trois variante_progressivite: prog/fb_info/fb_no_info où seule fb_no_info est sans information préalable sur la progressivité) - Q206-208"
s$variante_progressivite[!is.na(s$progressivite_feedback_sans_info)] <<- "fb_no_info"
s$variante_progressivite[!is.na(s$progressivite_feedback_avec_info)] <<- "fb_info"
s$variante_progressivite[s$variante_taxe_info=='p'] <<- "prog" # !is.na(s$progressivite_progressif) |
s$variante_progressivite[s$variante_taxe_info=='f' & s$apres_modifs==FALSE] <<- 'fb_no_info'
label(s$variante_progressivite) <<- "variante_progressivite: prog/fb_info/fb_no_info Variante aléatoire du bloc de questions où figure 'progressivite'. prog: info sur la progressivité / fb: feedback sur le statut gagnant/perdant simulé, info/no_info: avec/sans info sur la progressivité de la mesure" # , seulement pour apres_modifs=T
s$info_progressivite <<- FALSE
s$info_progressivite[s$variante_taxe_info=='p' | s$variante_progressivite=='fb_info'] <<- T
label(s$info_progressivite) <<- "info_progressivite: Indicatrice qu'a été montrée l'information que la hausse de la taxe carbone compensée avantagerait les plus modestes"
s$variante_monetaire[is.na(s$variante_monetaire)] <<- 0 # concerne seulement une observation. Évite des complications inutiles.
s$age_18_24 <<- 1*(s$age == '18 à 24 ans')
s$age_25_34 <<- 1*(s$age == '25 à 34 ans')
s$age_35_49 <<- 1*(s$age == '35 à 49 ans')
s$age_50_64 <<- 1*(s$age == '50 à 64 ans')
s$age_65_plus <<- 1*(s$age == '65 ans ou plus')
s$score_ges <<- 1 * (s$ges_CO2 == TRUE) + 1*(s$ges_CH4 == TRUE) + 1*(s$ges_O2 == FALSE) + 1*(s$ges_pm == FALSE)
label(s$score_ges) <<- "score_ges: Somme des bonnes réponses au questionnaire gaz à effet de serre (ges_O2/CH4/pm/CO2)"
s$score_climate_call <<- 1*(s$ges_avion == TRUE) + 1*(s$ges_boeuf == TRUE) + 1*(s$ges_nucleaire == FALSE)
label(s$score_climate_call) <<- "score_climate_call: Somme des bonnes réponses au questionnaire Climate Call (avion-train / boeuf-pates / nucleaire-eolien) ges_avion/boeuf/nucleaire"
s$mauvaise_qualite[s$generation_CC_aucune==T & (s$generation_CC_1960==T | s$generation_CC_1990==T | s$generation_CC_2020==T | s$generation_CC_2050==T)] <<- 1.2 + s$mauvaise_qualite[s$generation_CC_aucune==T & (s$generation_CC_1960==T | s$generation_CC_1990==T | s$generation_CC_2020==T | s$generation_CC_2050==T)]
s$generation_CC_min <<- 1960*(s$generation_CC_1960==T) + 1990*(s$generation_CC_1990==T)*(s$generation_CC_1960!=T) + 2020*(s$generation_CC_2020==T)*(s$generation_CC_1960!=T)*(s$generation_CC_1990!=T) + 2050*(s$generation_CC_2050==T)*(s$generation_CC_1960!=T)*(s$generation_CC_1990!=T)*(s$generation_CC_2020!=T)
s$generation_CC_max <<- 2050*(s$generation_CC_2050==T) + 2020*(s$generation_CC_2020==T)*(s$generation_CC_2050!=T) + 1990*(s$generation_CC_1990==T)*(s$generation_CC_2020!=T)*(s$generation_CC_2050!=T) + 1960*(s$generation_CC_1960==T)*(s$generation_CC_2050!=T)*(s$generation_CC_1990!=T)*(s$generation_CC_2020!=T)
s$generation_CC_max[s$generation_CC_aucune==T] <<- s$generation_CC_min[s$generation_CC_aucune==T] <<- NA
s$nb_generation_CC <<- (s$generation_CC_1960==T) + (s$generation_CC_2050==T) + (s$generation_CC_1990==T) + (s$generation_CC_2020==T)
label(s$generation_CC_min) <<- "generation_CC_min: Génération minimale de Français qui sera gravement affectée par le changeent climatique (1960/1990/2020/2050/NA si le répondant à répondu aucune d'entre elles) - Q71"
label(s$generation_CC_max) <<- "generation_CC_max: Génération maximale de Français qui sera gravement affectée par le changeent climatique (1960/1990/2020/2050/NA si le répondant à répondu aucune d'entre elles) - Q71"
label(s$nb_generation_CC) <<- "nb_generation_CC: Nombre de générations de Français qui seront gravement affectées par le changeent climatique (de 0 à 4) - Q71"
s$duree_info[s$info_CC==1 & s$info_PM==1] <<- s$duree_info_CC_PM[s$info_CC==1 & s$info_PM==1]
s$duree_info[s$info_CC==0 & s$info_PM==1] <<- s$duree_info_PM[s$info_CC==0 & s$info_PM==1]
s$duree_info[s$info_CC==1 & s$info_PM==0] <<- s$duree_info_CC[s$info_CC==1 & s$info_PM==0]
s$duree_info[s$info_CC==0 & s$info_PM==0] <<- s$duree_no_info[s$info_CC==0 & s$info_PM==0]
label(s$duree_info) <<- "duree_info: Temps de soumission - Ancrage (information procurée ou non au début sur changement climatique ou particules fines) (duree_info_CC/PM/CC_PM/no_info)"
for (v in c("autonomie", "priorite", "etats", "global", "trop")) {
s[[paste("aide_non", v, sep="_")]] <<- NA
s[[paste("aide_non", v, sep="_")]][!is.na(s$transferts_inter_info) & s$transferts_inter_info==T & s$aide_2p==T] <<- s[[paste("aide_non", v, "i", sep="_")]][!is.na(s$transferts_inter_info) & s$transferts_inter_info==T & s$aide_2p==T]
s[[paste("aide_non", v, sep="_")]][!is.na(s$transferts_inter_info) & s$transferts_inter_info==FALSE & s$aide_2p==T] <<- s[[paste("aide_non", v, "ni", sep="_")]][!is.na(s$transferts_inter_info) & s$transferts_inter_info==FALSE & s$aide_2p==T]
label(s[[paste("aide_non", v, sep="_")]]) <<- Label(s[[paste("aide_non", v, "i", sep="_")]])
}
s$revenu_decile <<- 1 + 1 * ((s$revenu > 237) + (s$revenu > 789) + (s$revenu > 1151) + (s$revenu > 1436) + (s$revenu > 1677) + (s$revenu > 1927) + (s$revenu > 2231) + (s$revenu > 2657) + (s$revenu > 3462))
s$revenu_quintile <<- 1 + 1 * ((s$revenu > 789) + (s$revenu > 1436) + (s$revenu > 1927) + (s$revenu > 2657))
s$tax_approval <<- s$taxe_approbation=='Oui'
s$tax_acceptance <<- s$taxe_approbation!='Non'
s$tax_cible_acceptance <<- 1*(s$taxe_cible_approbation!='Non')
s$win_cible_category <<- 1*(s$gagnant_cible_categorie!='Perdant')
label(s$tax_approval) <<- "tax_approval: Approbation initiale de la hausse de la taxe carbone compensée: taxe_approbation=='Oui'"
label(s$tax_acceptance) <<- "tax_acceptance: Acceptation initiale de la hausse de la taxe carbone compensée: taxe_approbation!='Non'"
label(s$tax_cible_acceptance) <<- "tax_cible_acceptance: Acceptation de la hausse de la taxe carbone compensée par recyclage ciblé (cible: 20/30/40/50% les plus modestes): 1*(taxe_cible_approbation!='Non')"
label(s$win_cible_category) <<- "win_cible_category: Le répondant s'estime non perdant suite à la hausse de la taxe carbone compensée par recyclage ciblé (cible: 20/30/40/50% les plus modestes): 1*(s$gagnant_cible_categorie!='Perdant')"
s$update_correct <<- ((s$simule_gagnant==1 & s$gagnant_feedback_categorie=='Gagnant' & s$gagnant_categorie!='Gagnant')
+ (s$simule_gagnant==0 & s$gagnant_feedback_categorie=='Perdant' & s$gagnant_categorie!='Perdant')
- (s$simule_gagnant==1 & s$gagnant_feedback_categorie=='Perdant' & s$gagnant_categorie!='Perdant')
- (s$simule_gagnant==0 & s$gagnant_feedback_categorie=='Gagnant' & s$gagnant_categorie!='Gagnant'))
label(s$update_correct) <<- "update_correct: Différence entre l'indicatrice de ne pas se penser gagnant/perdant et le penser après feedback infirmant, moins la même après feedback confirmant"
s$update_correct_large <<- ((s$simule_gagnant==1 & ((s$gagnant_feedback_categorie=='Gagnant' & s$gagnant_categorie!='Gagnant') | (s$gagnant_feedback_categorie!='Perdant' & s$gagnant_categorie=='Perdant')))
+ (s$simule_gagnant==0 & ((s$gagnant_feedback_categorie=='Perdant' & s$gagnant_categorie!='Perdant') | (s$gagnant_feedback_categorie!='Gagnant' & s$gagnant_categorie=='Gagnant')))
- (s$simule_gagnant==1 & ((s$gagnant_feedback_categorie=='Perdant' & s$gagnant_categorie!='Perdant') | (s$gagnant_feedback_categorie!='Gagnant' & s$gagnant_categorie=='Gagnant')))
- (s$simule_gagnant==0 & ((s$gagnant_feedback_categorie=='Gagnant' & s$gagnant_categorie!='Gagnant') | (s$gagnant_feedback_categorie!='Perdant' & s$gagnant_categorie=='Perdant'))))
label(s$update_correct_large) <<- "update_correct_large: Différence entre faire un update dans la bonne direction quand le feedback y conduit et faire un update dans la mauvaise direction"
s$feedback_confirme <<- (s$gagnant_categorie=='Gagnant' & s$simule_gagnant==1) | (s$gagnant_categorie=='Perdant' & s$simule_gagnant==0)
s$feedback_infirme <<- (s$gagnant_categorie=='Perdant' & s$simule_gagnant==1) | (s$gagnant_categorie=='Gagnant' & s$simule_gagnant==0)
s$feedback_confirme_large <<- s$feedback_confirme | (s$gagnant_categorie!='Perdant' & s$simule_gagnant==1) | (s$gagnant_categorie!='Gagnant' & s$simule_gagnant==0)
s$feedback_infirme_large <<- s$feedback_infirme | (s$gagnant_categorie!='Perdant' & s$simule_gagnant==0) | (s$gagnant_categorie!='Gagnant' & s$simule_gagnant==1)
label(s$feedback_confirme) <<- "feedback_confirme: Indicatrice de se penser et être simulé gagnant/perdant (gagnant_categorie, simule_gagnant)"
label(s$feedback_infirme) <<- "feedback_infirme: Indicatrice de se penser gagnant et être simulé perdant, ou l'inverse (gagnant_categorie, simule_gagnant)"
label(s$feedback_confirme_large) <<- "feedback_confirme_large: Indicatrice de se penser non perdant et être simulé gagnant, ou de se penser non gagnant et être simulé perdant (gagnant_categorie, simule_gagnant)"
label(s$feedback_infirme_large) <<- "feedback_infirme_large: Indicatrice de se penser non gagnant et être simulé gagnant, ou de se penser non perdant et être simulé perdant (gagnant_categorie, simule_gagnant)"
categories_depenses <- c("sante", "retraites", "protection", "education", "recherche", "loisirs", "infrastructures", "justice", "armee", "securite", "aide")
# for (i in 0:10) s[[paste('dep', i, 'en_position', sep='_')]] <<- NA
for (i in 0:10) {
s[[paste('dep', i, 'en_position', sep='_')]] <<- (s$en_position_1==i) + 2*(s$en_position_2==i)  + 3*(s$en_position_3==i)  + 4*(s$en_position_4==i)  + 5*(s$en_position_5==i)  + 6*(s$en_position_6==i)  + 7*(s$en_position_7==i)  + 8*(s$en_position_8==i)  + 9*(s$en_position_9==i)  + 10*(s$en_position_10==i)
label(s[[paste('dep', i, 'en_position', sep='_')]]) <<- paste(paste('dep', i, 'en_position', sep='_'), ": Position à laquelle est affichée la catégorie de dépense ", i, "(", categories_depenses[i], ") (cf. en_position_i)", sep="")
# for (o in 1:nrow(s)) {
#   j <- s[[paste('en_position', i, sep='_')]][o]
#   if (!is.na(j)) s[[paste('dep', j, 'en_position', sep='_')]][o] <<- i
#   s[[paste('dep', j, 'en_position', sep='_')]][!is.na(s$en_position_0)] <-
# }
>>>>>>> master
}
s$b_i[s$variante_taxe_info=='f' & bins==i] <<- b_i[i] }
plot(1:nb_bins, G_F_i, type='l', xlab=paste('bins of', by_variable, '(lowest to highest)'), ylab="Probability that G^F ≠ 'Perdant'") + grid()
lowess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain - b_i), data=s)
f__1 <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(lowess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
plot(seq(-500, 300, by=10), predict(lowess_gains, newdata = seq(-500, 300, by=10)), xlab=paste('simule_gain - biais_bin(i), où bin vient de', by_variable), ylab='Proba that G != Perdant', type='l', col='red') + grid()
hat_g_F_i <- f__1(G_F_i)
hat_alpha_i <- 1 + (gain_i - hat_g_F_i)/(b_i*local_b + (!local_b)*wtd.mean(s$simule_gain - s$gain, weights = s$weight))
alphas_i <- mean_alphas_i <- median_alphas_i <- c()
for (i in 1:nb_bins) {
alphas_i[s$variante_taxe_info=='f' & bins==i] <- 1 + (s$gain[s$variante_taxe_info=='f' & bins==i] - hat_g_F_i[i])/(b_i[i]*local_b + (!local_b)*(s$simule_gain[s$variante_taxe_info=='f' & bins==i] - s$gain[s$variante_taxe_info=='f' & bins==i]))
mean_alphas_i <- c(mean_alphas_i, wtd.mean(alphas_i[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
median_alphas_i <- c(median_alphas_i, wtd.median(alphas_i[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
<<<<<<< HEAD
name_by_var <- paste(by_variable, 'i', sep='_')
if (return=='alpha') return(median(hat_alpha_i))
else if (return=='all') return(list('alpha'=median(hat_alpha_i),  name_by_var=variable_i, 'G_i'=G_i, 'gain_i'=gain_i,
'b_i'=b_i ,'G_F_i'=G_F_i, 'hat_g_F_i'=hat_g_F_i, 'hat_alpha_i'=hat_alpha_i,
'mean(alphas_i)'=wtd.mean(alphas_i, weights = s$weight, na.rm=T),
'median(alphas_i)'=wtd.median(alphas_i, weight = s$weight, na.rm=T), 'mean_alphas_i'=mean_alphas_i, 'median_alphas_i'=median_alphas_i)) #
else if (return=='hat_alpha_i') return(hat_alpha_i)
else if (return=='b_i') return(b_i)
else return(list('alpha'=median(hat_alpha_i), 'hat_alpha_i'=hat_alpha_i, 'b_i'=b_i))
}
# preferred specification:
confirmation_bias('simule_gain', 7, TRUE, 'all', 'median')
confirmation_bias <- function(by_variable = 'gain', nb_bin = 8, local_b = TRUE, return='all', method='median') { # return = c('all', '', 'alpha', 'hat_alpha_i', 'b_i')
nb_bins <- length(levels(binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", ordered=FALSE, weights=s$weight)))
bins <- binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", labels=c(1:nb_bins), ordered=FALSE, weights=s$weight)
gain_i <- G_F_i <- b_i <- G_i <- p_i <- variable_i <- c()
for (i in 1:nb_bins) {
p_i <- c(p_i, sum(s$weight[s$variante_taxe_info=='f' & bins==i])/sum(s$weight[s$variante_taxe_info=='f']))
G_i <- c(G_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
G_F_i <- c(G_F_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
if (method=='median') {
variable_i <- c(variable_i, wtd.median(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weight=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.median(s$gain[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.median((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
} else if (method=='mean') {
variable_i <- c(variable_i, wtd.mean(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weights=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.mean(s$gain[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.mean((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
s$b_i[s$variante_taxe_info=='f' & bins==i] <<- b_i[i] }
plot(1:nb_bins, G_F_i, type='l', xlab=paste('bins of', by_variable, '(lowest to highest)'), ylab="Probability that G^F ≠ 'Perdant'") + grid()
lowess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain - b_i), data=s)
f__1 <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(lowess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
plot(seq(-500, 300, by=10), predict(lowess_gains, newdata = seq(-500, 300, by=10)), xlab=paste('simule_gain - biais_bin(i), où bin vient de', by_variable), ylab='Proba that G != Perdant', type='l', col='red') + grid()
hat_g_F_i <- f__1(G_F_i)
hat_alpha_i <- 1 + (gain_i - hat_g_F_i)/(b_i*local_b + (!local_b)*wtd.mean(s$simule_gain - s$gain, weights = s$weight))
alphas_i <- mean_alphas_i <- median_alphas_i <- c()
for (i in 1:nb_bins) {
alphas_i[s$variante_taxe_info=='f' & bins==i] <- 1 + (s$gain[s$variante_taxe_info=='f' & bins==i] - hat_g_F_i[i])/(s$simule_gain[s$variante_taxe_info=='f' & bins==i] - s$gain[s$variante_taxe_info=='f' & bins==i])
mean_alphas_i <- c(mean_alphas_i, wtd.mean(alphas_i[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
median_alphas_i <- c(median_alphas_i, wtd.median(alphas_i[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
name_by_var <- paste(by_variable, 'i', sep='_')
if (return=='alpha') return(median(hat_alpha_i))
else if (return=='all') return(list('alpha'=median(hat_alpha_i),  name_by_var=variable_i, 'G_i'=G_i, 'gain_i'=gain_i,
'b_i'=b_i ,'G_F_i'=G_F_i, 'hat_g_F_i'=hat_g_F_i, 'hat_alpha_i'=hat_alpha_i,
'mean(alphas_i)'=wtd.mean(alphas_i, weights = s$weight, na.rm=T),
'median(alphas_i)'=wtd.median(alphas_i, weight = s$weight, na.rm=T), 'mean_alphas_i'=mean_alphas_i, 'median_alphas_i'=median_alphas_i)) #
else if (return=='hat_alpha_i') return(hat_alpha_i)
else if (return=='b_i') return(b_i)
else return(list('alpha'=median(hat_alpha_i), 'hat_alpha_i'=hat_alpha_i, 'b_i'=b_i))
}
# preferred specification:
confirmation_bias('simule_gain', 7, TRUE, 'all', 'median')
confirmation_bias <- function(by_variable = 'gain', nb_bin = 8, local_b = TRUE, return='all', method='median') { # return = c('all', '', 'alpha', 'hat_alpha_i', 'b_i')
nb_bins <- length(levels(binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", ordered=FALSE, weights=s$weight)))
bins <- binning(s[[by_variable]], bins=nb_bin, method="wtd.quantile", labels=c(1:nb_bins), ordered=FALSE, weights=s$weight)
gain_i <- G_F_i <- b_i <- G_i <- p_i <- variable_i <- c()
for (i in 1:nb_bins) {
p_i <- c(p_i, sum(s$weight[s$variante_taxe_info=='f' & bins==i])/sum(s$weight[s$variante_taxe_info=='f']))
G_i <- c(G_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
G_F_i <- c(G_F_i, sum(s$weight[s$variante_taxe_info=='f' & s$gagnant_feedback_categorie!='Perdant' & bins==i])/sum(s$weight[s$variante_taxe_info=='f' & bins==i]))
if (method=='median') {
variable_i <- c(variable_i, wtd.median(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weight=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.median(s$gain[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.median((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
} else if (method=='mean') {
variable_i <- c(variable_i, wtd.mean(s[[by_variable]][s$variante_taxe_info=='f' & bins==i], weights=s$weight[s$variante_taxe_info=='f' & bins==i]))
gain_i <- c(gain_i, wtd.mean(s$gain[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
b_i <- c(b_i, wtd.mean((s$simule_gain - s$gain)[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
s$b_i[s$variante_taxe_info=='f' & bins==i] <<- b_i[i] }
plot(1:nb_bins, G_F_i, type='l', xlab=paste('bins of', by_variable, '(lowest to highest)'), ylab="Probability that G^F ≠ 'Perdant'") + grid()
lowess_gains <- loess((gagnant_categorie!='Perdant') ~ I(simule_gain - b_i), data=s)
f__1 <- function(x, xmin=-500, xmax=300, by=10) approxfun(predict(lowess_gains, newdata = seq(xmin, xmax, by=by)), seq(xmin, xmax, by=by), rule=2)(x) # imputes extremal values when outside bonds
plot(seq(-500, 300, by=10), predict(lowess_gains, newdata = seq(-500, 300, by=10)), xlab=paste('simule_gain - biais_bin(i), où bin vient de', by_variable), ylab='Proba that G != Perdant', type='l', col='red') + grid()
hat_g_F_i <- f__1(G_F_i)
hat_alpha_i <- 1 + (gain_i - hat_g_F_i)/(b_i*local_b + (!local_b)*wtd.mean(s$simule_gain - s$gain, weights = s$weight))
alphas_i <- mean_alphas_i <- median_alphas_i <- c()
for (i in 1:nb_bins) {
alphas_i[s$variante_taxe_info=='f' & bins==i] <- 1 + (s$gain[s$variante_taxe_info=='f' & bins==i] - hat_g_F_i[i])/(s$simule_gain[s$variante_taxe_info=='f' & bins==i] - s$gain[s$variante_taxe_info=='f' & bins==i])
mean_alphas_i <- c(mean_alphas_i, wtd.mean(alphas_i[s$variante_taxe_info=='f' & bins==i], weights = s$weight[s$variante_taxe_info=='f' & bins==i]))
median_alphas_i <- c(median_alphas_i, wtd.median(alphas_i[s$variante_taxe_info=='f' & bins==i], weight = s$weight[s$variante_taxe_info=='f' & bins==i]))
}
name_by_var <- paste(by_variable, 'i', sep='_')
if (return=='alpha') return(median(hat_alpha_i))
else if (return=='all') return(list('alpha'=median(hat_alpha_i),  name_by_var=variable_i, 'G_i'=G_i, 'gain_i'=gain_i,
'b_i'=b_i ,'G_F_i'=G_F_i, 'hat_g_F_i'=hat_g_F_i, 'hat_alpha_i'=hat_alpha_i,
'share_alphas_i>0'=sum(s$weight[alphas_i>0 & s$variante_taxe_info=='f'])/sum(s$weight[s$variante_taxe_info=='f']), 'share_alphas_i>1'=sum(s$weight[alphas_i>1 & s$variante_taxe_info=='f'])/sum(s$weight[s$variante_taxe_info=='f']),
'mean(alphas_i)'=wtd.mean(alphas_i, weights = s$weight, na.rm=T),
'median(alphas_i)'=wtd.median(alphas_i, weight = s$weight, na.rm=T), 'mean_alphas_i'=mean_alphas_i, 'median_alphas_i'=median_alphas_i)) #
else if (return=='hat_alpha_i') return(hat_alpha_i)
else if (return=='b_i') return(b_i)
else return(list('alpha'=median(hat_alpha_i), 'hat_alpha_i'=hat_alpha_i, 'b_i'=b_i))
}
# preferred specification:
confirmation_bias('simule_gain', 7, TRUE, 'all', 'median')
bins <- binning(s$simule_gain, bins=7, method="wtd.quantile", labels=c(1:7), ordered=FALSE, weights=s$weight)
max(bins[bins==4])
max(n(bins[bins==4]))
max(s$simule_gain[bins==4])
# Bizarre: les gain = non affectés sont en moyenne perdants selon simule_gain ! (valable selon quand on pondère) => TODO: clean numbers simule_gain
decrit(s$simule_gain[s$gain==0 & s$variante_taxe_info=='f'], weights= s$weight[s$gain==0 & s$variante_taxe_info=='f'])
=======
prepare_s(exclude_screened=FALSE, exclude_speeder=FALSE, only_finished=T) # TODO: let only_finished = FALSE
sa <- s
# prepare_s(exclude_screened=FALSE, exclude_speeder=FALSE)
# se <- s
# prepare_s(exclude_screened=FALSE)
# sp <- s
prepare_s()
write.csv(s, "survey_prepared.csv")
decrit(s$nb_generation_CC)
decrit(s$generation_CC_min)
decrit(s$update_correct)
decrit(s$win_cible_category)
decrit(s$Elasticite_chauffage_perso)
decrit(s$elasticite_chauffage_perso)
>>>>>>> master
=======
}
if ((n.vars>1) & (length(type)>1) & (addmargins==TRUE)) {
warning("WARNING: Only row totals added when more than one table type requested")
#Code lower down selecting type of margin implements this...
}
if ((length(type)>1) & (subtotals==FALSE)) {
warning("WARNING: Can only request supply one table type if requesting suppression of subtotals; suppression of subtotals not executed")
subtotals <- TRUE
}
if ((length(type)==1) & (subtotals==FALSE)) {
choices <- c("frequency", "row.pct", "column.pct", "joint.pct", "total.pct")
tp <- match.arg(type, choices)
if (tp %in% c("row.pct","column.pct","joint.pct")) {
warning("WARNING: subtotals can only be suppressed for tables of type 'frequency' or 'total.pct'")
subtotals<- TRUE
}
}
if ((n.vars > 2) & (n.col.vars>1) & (subtotals==FALSE))
warning("WARNING: suppression of subtotals assumes only 1 col var; table flattened accordingly")
if ( (subtotals==FALSE) & (n.vars>2) )  {
#If subtotals not required AND total table vars > 2
#Reassign all but last col.var as row vars
#[because, for simplicity, Crosstabs assumes removal of subtotals uses tables with only ONE col var]
#N.B. Subtotals only present in tables with > 2 cross-classified vars...
if (length(col.vars)>1) {
row.vars <- c(row.vars,col.vars[-length(col.vars)])
col.vars <- col.vars[length(col.vars)]
n.row.vars <- length(row.vars)
n.col.vars <- 1
}
}
#If dec.places not set by user, set to 2 unlesss only one table of type frequency requested,
#in which case set to 0.  [Leaves user with possibility of having frequency tables with > 0 dp]
if (is.null(dec.places)) {
if ((length(type)==1) & (type[1]=="frequency")) {
dec.places <- 0
} else {
dec.places <-2
}
}
#Take the original input data, whatever form originally supplied in,
#convert into table format using requested row and col vars, and save as 'tbl'
args <- list(...)
if (length(args) > 1) {
if (!all(sapply(args, is.factor)))
stop("If more than one argument is passed then all must be factors")
tbl <- table(...)
}
else {
if (is.factor(...)) {
tbl <- table(...)
}
else if (is.table(...)) {
tbl <- eval(...)
}
else if (is.data.frame(...)) {
#tbl <- table(...)
if (is.null(row.vars) && is.null(col.vars)) {
tbl <- table(...)
}
else {
var.names <- c(row.vars,col.vars)
A <- (...)
tbl <- table(A[var.names])
if(length(var.names==1)) names(dimnames(tbl)) <- var.names
#[table() only autocompletes dimnames for multivariate Crosstabs of dataframes]
}
}
else if (class(...) == "ftable") {
tbl <- eval(...)
if (is.null(row.vars) && is.null(col.vars)) {
row.vars <- names(attr(tbl, "row.vars"))
col.vars <- names(attr(tbl, "col.vars"))
}
tbl <- as.table(tbl)
}
else if (class(...) == "ctab") {
tbl <- eval(...)
if (is.null(row.vars) && is.null(col.vars)) {
row.vars <- tbl$row.vars
col.vars <- tbl$col.vars
}
for (opt in c("dec.places", "type", "style", "percentages",
"addmargins", "subtotals")) if (is.null(get(opt)))
assign(opt, eval(parse(text = paste("tbl$", opt,
sep = ""))))
tbl <- tbl$table
}
else {
stop("first argument must be either factors or a table object")
}
}
#Convert supplied table style into full text string (e.g. "l" becomes "long")
style <- match.arg(style, c("long", "wide"))
#Extract row and col names to be used in creating 'tbl' from supplied input data
nms <- names(dimnames(tbl))
z <- length(nms)
if (!is.null(row.vars) && !is.numeric(row.vars)) {
row.vars <- order(match(nms, row.vars), na.last = NA)
}
if (!is.null(col.vars) && !is.numeric(col.vars)) {
col.vars <- order(match(nms, col.vars), na.last = NA)
}
if (!is.null(row.vars) && is.null(col.vars)) {
col.vars <- (1:z)[-row.vars]
}
if (!is.null(col.vars) && is.null(row.vars)) {
row.vars <- (1:z)[-col.vars]
}
if (is.null(row.vars) && is.null(col.vars)) {
col.vars <- z
row.vars <- (1:z)[-col.vars]
}
#Take the original input data, converted into table format using supplied row and col vars (tbl)
#and create a second version (Crosstab) which stores results as percentages if a percentage table type is requested.
if (type[1] == "frequency")
Crosstab <- tbl
else
Crosstab <- mk.pcnt.tbl(tbl, type[1])
#If multiple table types requested, create and add these to
if (length(type) > 1) {
tbldat <- as.data.frame.table(Crosstab)
z <- length(names(tbldat)) + 1
tbldat[z] <- 1
pcntlab <- type
pcntlab[match("frequency", type)] <- "Count"
pcntlab[match("row.pct", type)] <- "Row %"
pcntlab[match("column.pct", type)] <- "Column %"
pcntlab[match("joint.pct", type)] <- "Joint %"
pcntlab[match("total.pct", type)] <- "Total %"
for (i in 2:length(type)) {
if (type[i] == "frequency")
Crosstab <- tbl
else Crosstab <- mk.pcnt.tbl(tbl, type[i])
Crosstab <- as.data.frame.table(Crosstab)
Crosstab[z] <- i
tbldat <- rbind(tbldat, Crosstab)
}
tbldat[[z]] <- as.factor(tbldat[[z]])
levels(tbldat[[z]]) <- pcntlab
Crosstab <- xtabs(Freq ~ ., data = tbldat)
names(dimnames(Crosstab))[z - 1] <- ""
}
#Add margins if required, adding only those margins appropriate to user request
if (addmargins==TRUE) {
vars <- c(row.vars,col.vars)
if (length(type)==1) {
if (type=="row.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.vars]))
}
else
{ if (type=="column.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[n.row.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.row.vars]))
}
else
{ if (type=="joint.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[(n.row.vars)],vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[(n.row.vars)],vars[n.vars]))
}
else #must be total.pct OR frequency
{ Crosstab <- addmargins(Crosstab)
tbl <- addmargins(tbl)
}
}
}
}
#If more than one table type requested, only adding row totals makes any sense...
if (length(type)>1) {
Crosstab <- addmargins(Crosstab,margin=c(vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.vars]))
}
}
#If subtotals not required, and total vars > 2, create dataframe version of table, with relevent
#subtotal rows / cols dropped [Subtotals only present in tables with > 2 cross-classified vars]
t1 <- NULL
if ( (subtotals==FALSE) & (n.vars>2) )  {
#Create version of Crosstab in ftable format
t1 <- Crosstab
t1 <- ftable(t1,row.vars=row.vars,col.vars=col.vars)
#Convert to a dataframe
t1 <- as.data.frame(format(t1),stringsAsFactors=FALSE)
#Remove backslashes from category names AND colnames
t1 <- apply(t1[,],2, function(x) gsub("\"","",x))
#Remove preceding and trailing spaces from category names to enable accurate capture of 'sum' rows/cols
#[Use of grep might extrac category labels with 'sum' as part of a longer one or two word string...]
t1 <- apply(t1,2,function(x) gsub("[[:space:]]*$","",gsub("^[[:space:]]*","",x)))
#Reshape dataframe to that variable and category labels display as required
#(a) Move col category names down one row; and move col variable name one column to right
t1[2,(n.row.vars+1):ncol(t1)] <- t1[1,(n.row.vars+1):ncol(t1)]
t1[1,] <- ""
t1[1,(n.row.vars+2)] <- t1[2,(n.row.vars+1)]
#(b) Drop the now redundant column separating the row.var labels from the table data + col.var labels
t1 <- t1[,-(n.row.vars+1)]
#In 'lab', assign category labels for each variable to all rows (to allow identification of sub-totals)
lab <- t1[,1:n.row.vars]
for (c in 1:n.row.vars) {
for (r in 2:nrow(lab)) {
if (lab[r,c]=="") lab[r,c] <- lab[r-1,c]
}
}
lab <- (apply(lab[,1:n.row.vars],2,function(x) x=="Sum"))
lab <- apply(lab,1,sum)
#Filter out rows of dataframe containing subtotals
t1 <- t1[((lab==0) | (lab==n.row.vars)),]
#Move the 'Sum' label associated with last row to the first column; in the process
#setting the final row labels associated with other row variables to ""
t1[nrow(t1),1] <- "Sum"
t1[nrow(t1),(2:n.row.vars)] <- ""
#set row and column names to NULL
rownames(t1) <- NULL
colnames(t1) <- NULL
}
#Create output object 'result' [class: Crosstab]
result <- NULL
#(a) record of argument values used to produce tabular output
result$row.vars <- row.vars
result$col.vars <- col.vars
result$dec.places <- dec.places
result$type <- type
result$style <- style
result$percentages <- percentages
result$addmargins <- addmargins
result$subtotals <- subtotals
#(b) tabular output [3 variants]
result$table <- tbl  #Stores original cross-tab frequency counts without margins [class: table]
result$Crosstab <- Crosstab #Stores cross-tab in table format using requested style(frequency/pct) and table margins (on/off)
#[class: table]
result$Crosstab.nosub <- t1  #Crosstab with subtotals suppressed [class: dataframe; or NULL if no subtotals suppressed]
class(result) <- "Crosstab"
#Return 'result' as output of function
result
}
print.Crosstab <- function(x,dec.places=x$dec.places,subtotals=x$subtotals,...) {
row.vars <- x$row.vars
col.vars <- x$col.vars
n.row.vars <- length(row.vars)
n.col.vars <- length(col.vars)
n.vars <- n.row.vars + n.col.vars
if (length(x$type)>1) {
z<-length(names(dimnames(x$Crosstab)))
if (x$style=="long") {
row.vars<-c(row.vars,z)
} else {
col.vars<-c(z,col.vars)
}
}
if (n.vars==1) {
if (length(x$type)==1) {
tmp <- data.frame(round(x$Crosstab,x$dec.places))
colnames(tmp)[2] <- ifelse(x$type=="frequency","Count","%")
print(tmp,row.names=FALSE)
} else {
print(round(x$Crosstab,x$dec.places))
}
}
#If table has only 2 dimensions, or subtotals required for >2 dimensional table,
#print table using ftable() on x$Crosstab
if ((n.vars == 2) | ((subtotals==TRUE) & (n.vars>2))) {
tbl <- ftable(x$Crosstab,row.vars=row.vars,col.vars=col.vars)
if (!all(as.integer(tbl)==as.numeric(tbl))) tbl <- round(tbl,dec.places)
print(tbl,...)
}
#If subtotals NOT required AND > 2 dimensions, print table using write.table() on x$Crosstab.nosub
if ((subtotals==FALSE) & (n.vars>2))  {
t1 <- x$Crosstab.nosub
#Convert numbers to required decimal places, right aligned
width <- max( nchar(t1[1,]), nchar(t1[2,]), 7 )
dec.places <- x$dec.places
number.format <- paste("%",width,".",dec.places,"f",sep="")
t1[3:nrow(t1),((n.row.vars+1):ncol(t1))] <- sprintf(number.format,as.numeric(t1[3:nrow(t1),((n.row.vars+1):ncol(t1))]))
#Adjust column variable label to same width as numbers, left aligned, padding with trailing spaces as required
col.var.format <- paste("%-",width,"s",sep="")
t1[1,(n.row.vars+1):ncol(t1)] <- sprintf(col.var.format,t1[1,(n.row.vars+1):ncol(t1)])
#Adjust column category labels to same width as numbers, right aligned, padding with preceding spaces as required
col.cat.format <- paste("%",width,"s",sep="")
t1[2,(n.row.vars+1):ncol(t1)] <- sprintf(col.cat.format,t1[2,(n.row.vars+1):ncol(t1)])
#Adjust row labels so that each column is of fixed width, using trailing spaces as required
for (i in 1:n.row.vars) {
width <- max(nchar(t1[,i])) + 2
row.lab.format <- paste("%-",width,"s",sep="")
t1[,i] <- sprintf(row.lab.format,t1[,i])
}
write.table(t1,quote=FALSE,col.names=FALSE,row.names=FALSE)
}
}
##### Data #####
## 2.1 Survey "Beliefs climate policies"
decrit(s$sexe)
##### Data #####
## 2.1 Survey "Beliefs climate policies"
decrit(s$sexe, weights = s$weight)
decrit(s$age)
decrit(s$csp)
decrit(s$diplome4)
decrit(s$taille_agglo)
decrit(s$region)
# Table II: Proportion of respondents per target of the payment
decrit(s$cible)
# Table II: Proportion of respondents per target of the payment
decrit(s$cible, weights = s$weight)
# Table II: Proportion of respondents per target of the payment
decrit(s$Cible)
# Table II: Proportion of respondents per target of the payment
decrit(n(s$cible))
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(sa$duree < 7*60, weights = sa$weight)
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(sa$duree < 7*60)
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(s$duree < 7*60, weights = s$weight) # 4%
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(s$duree < 9*60, weights = s$weight) # 4%
# Response time uncorrelated with preferences:
summary(lm(taxe_approbation!='Non' ~ duree, data=s, weights = s$weight))
summary(lm(gagnant_categorie!='Perdant' ~ duree, data=s, weights = s$weight))
summary(lm(gain ~ duree, data=s, weights = s$weight))
summary(lm(taxe_approbation!='Non' ~ duree + I(duree^2), data=s, weights = s$weight)) # .
summary(lm(gagnant_categorie!='Perdant' ~ duree + I(duree^2), data=s, weights = s$weight))
summary(lm(gain ~ duree + I(duree^2), data=s, weights = s$weight))
summary(lm(taxe_approbation!='Non' ~ duree + I(duree^2), data=s, weights = s$weight)) # .
# Bad quality screened out
wtd.mean(sa$test_qualite!='Un peu', weights = sa$weight)
# 2.1.3 Ensuring Data Quality
# Speeder screened out
wtd.mean(sa$duree < 7*60, weights = sa$weight) # 4% in original sample
wtd.mean(s$duree < 7*60, weights = s$weight) # 4%
##### Data #####
## 2.1 Survey "Beliefs climate policies"
# 2.1.1 Table I: Sample Characteristics
decrit(s$sexe)
# Bad quality screened out
wtd.mean(sa$test_qualite!='Un peu', weights = sa$weight)
wtd.mean(s$test_qualite!='Un peu', weights = s$weight) # 0 in final sample
sum(s$taille_menage > 12)
sum(n(s$revenu) > n(s$rev_tot) | n(s$revenu) > 10000 | n(s$rev_tot) > 10000)
sum(n(s$revenu) > n(s$rev_tot) | s$taille_menage < s$nb_adultes | s$taille_menage < s$nb_14_et_plus | n(s$revenu) > 10000 | n(s$rev_tot) > 10000)
sum(s$mauvaise_qualite>0)
decrit(s$mauvaise_qualite) # 250
decrit(s$mauvaise_qualite > 0) # 250
# mauvaise_qualite uncorrelated with preferences
summary(lm(taxe_approbation!='Non' ~ mauvaise_qualite, data=s, weights = s$weight))
summary(lm(gagnant_categorie!='Perdant' ~ mauvaise_qualite, data=s, weights = s$weight))
summary(lm(gain ~ mauvaise_qualite, data=s, weights = s$weight))
s$taille_menage[s$taille_menage > 12] # looks like zipcode
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 - s$hausse_carburants, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 * pmax(2, s$nb_adultes) - s$hausse_carburants, weights = s$weight)
decrit(s$gain, weights = s$weight)
decrit(50 * pmax(2, s$nb_adultes) - s$hausse_chauffage, weights = s$weight)
decrit(110 * pmax(2, s$nb_adultes) - s$hausse_depenses, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 * pmin(2, s$nb_adultes) - s$hausse_carburants, weights = s$weight)
decrit(50 * pmin(2, s$nb_adultes) - s$hausse_chauffage, weights = s$weight)
decrit(110 * pmin(2, s$nb_adultes) - s$hausse_depenses, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage, weights = s$weight)
decrit(s$gain, weights = s$weight)
ggplot(data=s, aes(x=60 * pmin(2, nb_adultes) - hausse_carburants)) + geom_density() + xlim(c(-100, 200))
fit_housing$vrai_gain_chauffage <- 50 * pmin(2, fit_housing$nb_adultes) - fit_housing$obj
fit_housing$estimation_gain_chauffage <- 50 * pmin(2, fit_housing$nb_adultes) - fit_housing$fit
ggplot(data=fit_housing, aes(x=vrai_gain_chauffage)) +
geom_smooth(method = "auto", aes(y=1*(estimation_gain_chauffage > 0))) + ylim(c(0,1)) + xlab("Objective gain without fuel (density in black)") + ylab("P(gain - (hausse_carburants-60) > 0) i.e. proba gain") + xlim(c(-200, 120)) + geom_density(aes(y=..scaled..)) + geom_vline(xintercept=0, col='red')
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage)
decrit(s$gain, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_min, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_max, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_max)
decrit(s$gain > s$simule_gain, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
# Over-estimation of policy costs TODO: correct figures in paper
decrit(s$gain_fuel, weights = s$weight) # mean
decrit(s$gagnant_categorie, weights = s$weight)
decrit(s$gagnant_fuel_categorie, weights = s$weight) # 14% think they win (22% unaffected)
decrit(s$gagnant_chauffage_categorie, weights = s$weight) # 14% think they win (22% unaffected)
233.9086/1505.329
## 3.2 Robustness to assumptions on elasticities
decrit(s$Elasticite_fuel, weights = s$weight) # -0.43 perceived elasticity of French people
decrit(s$Elasticite_fuel_perso, weights = s$weight * s$depense_carburants) #
decrit(s$Elasticite_chauffage_perso, weights = s$weight * s$depense_chauffage) #
# 71% (resp. 80%) think they are strictly more contrained than average for fuel (resp. chauffage)
wtd.(s$Elasticite_fuel_perso > s$Elasticite_fuel, weights=s$weight, na.rm = T)
# 71% (resp. 80%) think they are strictly more contrained than average for fuel (resp. chauffage)
wtd.mean(s$Elasticite_fuel_perso > s$Elasticite_fuel, weights=s$weight, na.rm = T)
wtd.mean(s$Elasticite_chauffage_perso > s$Elasticite_chauffage, weights=s$weight, na.rm = T) # 80%
mar_old <- par()$mar
cex_old <- par()$cex
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
plot(density(objective_gains$transport, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$transport, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# (b) housing
plot(density(objective_gains$housing, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$housing, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# (c) both combined
plot(density(objective_gains$all, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$all, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# Figure 2: CDF of subjective vs. objective gain (including in the inelastic case)
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport_inelastic <- Ecdf(objective_gains_inelastic$transport)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_inelastic$x, cdf_transport_inelastic$y, lwd=2, lty=2, col="blue")
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
objective_gains <- read.csv2("df_objective_gains.csv")
subjective_gains <- read.csv2("df_subjective_gains.csv")
objective_gains_inelastic <- read.csv2("df_objective_gains_inelastic.csv")
objective_gains$transport <- n(objective_gains$gain_net_numeric_uc_fuel)
objective_gains$housing <- n(objective_gains$gain_net_numeric_uc_chauffage)
objective_gains$all <- n(objective_gains$gain_net_numeric_uc_taxe_carbone)
subjective_gains$transport <- n(subjective_gains$subjective_gain_numeric_fuel)
subjective_gains$housing <- n(subjective_gains$subjective_gain_numeric_chauffage)
subjective_gains$all <- n(subjective_gains$subjective_gain_numeric_taxe_carbone)
objective_gains_inelastic$transport <- n(objective_gains_inelastic$gain_net_numeric_uc_fuel)
objective_gains_inelastic$housing <- n(objective_gains_inelastic$gain_net_numeric_uc_chauffage)
objective_gains_inelastic$all <- n(objective_gains_inelastic$gain_net_numeric_uc_taxe_carbone)
objective_gains_inelastic <- read.csv2("df_objective_gains_inelastic.csv")
objective_gains$transport <- n(objective_gains$gain_net_numeric_uc_fuel)
objective_gains$housing <- n(objective_gains$gain_net_numeric_uc_chauffage)
objective_gains$all <- n(objective_gains$gain_net_numeric_uc_taxe_carbone)
subjective_gains$transport <- n(subjective_gains$subjective_gain_numeric_fuel)
subjective_gains$housing <- n(subjective_gains$subjective_gain_numeric_chauffage)
subjective_gains$all <- n(subjective_gains$subjective_gain_numeric_taxe_carbone)
objective_gains_inelastic$transport <- n(objective_gains_inelastic$gain_net_numeric_uc_fuel)
objective_gains_inelastic$housing <- n(objective_gains_inelastic$gain_net_numeric_uc_chauffage)
objective_gains_inelastic$all <- n(objective_gains_inelastic$gain_net_numeric_uc_taxe_carbone)
decrit(subjective_gains$transport)
decrit(subjective_gains$housing)
decrit(subjective_gains$all)
decrit(s$fioul)
decrit(s$gaz)
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
decrit(ss$fioul)
decrit(ss$gaz)
decrit(s$fioul)
names(s)
names(ss)[!(names(ss) %in% names(s))]
which(!(names(ss) %in% names(s)))
write.csv(s, "survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv")
ss <- read.csv("survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv", row.names = 1)
ss <- read.csv("survey_prepared.csv")
ss <- read.csv("survey_prepared.csv", row.names = NULL)
ss <- read.csv("survey_prepared.csv", row.names = TRUE)
ss <- read.csv("survey_prepared.csv")
duplicated(s$id)
which(duplicated(s$id))
write.csv(s, "survey_prepared.csv", row.names = NULL)
write.csv(s, "survey_prepared.csv", row.names = FALSe)
ss <- read.csv("survey_prepared.csv", skip = 1
)
ss <- read.csv("survey_prepared.csv", header = FALSE)
ss <- read.csv("survey_prepared.csv", header = T)
which(duplicated(names(s)))
write.csv(s[-c(1294,1666),], "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
write.csv(s[-c(1294,1666),], "survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv")
write.csv(s[-c(1294,1666),], "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
package("utils")
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
names(s)
names(ss)
names(ss)[!(names(ss) %in% names(s))]
names(ss)[!(names(s) %in% names(ss))]
head(ss$weight)
write.csv2(s, "survey_prepared.csv")
ss <- read.csv2("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
write.csv(s, "survey_prepared.csv", eol="\n\n")
ss <- read.csv("survey_prepared.csv", eol="\n\n")
ss <- read.csv("survey_prepared.csv",)
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
make.names(names(s))
which(make.names(names(s))!=names(s))
ss <- read.csv("survey_prepared.csv", check.names=FALSE)
write.csv(s, "survey_prepared.csv", row.names=FALSE)
ss <- read.csv("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
write.csv(s, "survey_prepared.csv", row.names='n')
write.csv(s, "survey_prepared.csv", row.names=FALSE)
ss <- read.csv("survey_prepared.csv", row.names=NULL)
>>>>>>> Stashed changes
=======
}
if ((n.vars>1) & (length(type)>1) & (addmargins==TRUE)) {
warning("WARNING: Only row totals added when more than one table type requested")
#Code lower down selecting type of margin implements this...
}
if ((length(type)>1) & (subtotals==FALSE)) {
warning("WARNING: Can only request supply one table type if requesting suppression of subtotals; suppression of subtotals not executed")
subtotals <- TRUE
}
if ((length(type)==1) & (subtotals==FALSE)) {
choices <- c("frequency", "row.pct", "column.pct", "joint.pct", "total.pct")
tp <- match.arg(type, choices)
if (tp %in% c("row.pct","column.pct","joint.pct")) {
warning("WARNING: subtotals can only be suppressed for tables of type 'frequency' or 'total.pct'")
subtotals<- TRUE
}
}
if ((n.vars > 2) & (n.col.vars>1) & (subtotals==FALSE))
warning("WARNING: suppression of subtotals assumes only 1 col var; table flattened accordingly")
if ( (subtotals==FALSE) & (n.vars>2) )  {
#If subtotals not required AND total table vars > 2
#Reassign all but last col.var as row vars
#[because, for simplicity, Crosstabs assumes removal of subtotals uses tables with only ONE col var]
#N.B. Subtotals only present in tables with > 2 cross-classified vars...
if (length(col.vars)>1) {
row.vars <- c(row.vars,col.vars[-length(col.vars)])
col.vars <- col.vars[length(col.vars)]
n.row.vars <- length(row.vars)
n.col.vars <- 1
}
}
#If dec.places not set by user, set to 2 unlesss only one table of type frequency requested,
#in which case set to 0.  [Leaves user with possibility of having frequency tables with > 0 dp]
if (is.null(dec.places)) {
if ((length(type)==1) & (type[1]=="frequency")) {
dec.places <- 0
} else {
dec.places <-2
}
}
#Take the original input data, whatever form originally supplied in,
#convert into table format using requested row and col vars, and save as 'tbl'
args <- list(...)
if (length(args) > 1) {
if (!all(sapply(args, is.factor)))
stop("If more than one argument is passed then all must be factors")
tbl <- table(...)
}
else {
if (is.factor(...)) {
tbl <- table(...)
}
else if (is.table(...)) {
tbl <- eval(...)
}
else if (is.data.frame(...)) {
#tbl <- table(...)
if (is.null(row.vars) && is.null(col.vars)) {
tbl <- table(...)
}
else {
var.names <- c(row.vars,col.vars)
A <- (...)
tbl <- table(A[var.names])
if(length(var.names==1)) names(dimnames(tbl)) <- var.names
#[table() only autocompletes dimnames for multivariate Crosstabs of dataframes]
}
}
else if (class(...) == "ftable") {
tbl <- eval(...)
if (is.null(row.vars) && is.null(col.vars)) {
row.vars <- names(attr(tbl, "row.vars"))
col.vars <- names(attr(tbl, "col.vars"))
}
tbl <- as.table(tbl)
}
else if (class(...) == "ctab") {
tbl <- eval(...)
if (is.null(row.vars) && is.null(col.vars)) {
row.vars <- tbl$row.vars
col.vars <- tbl$col.vars
}
for (opt in c("dec.places", "type", "style", "percentages",
"addmargins", "subtotals")) if (is.null(get(opt)))
assign(opt, eval(parse(text = paste("tbl$", opt,
sep = ""))))
tbl <- tbl$table
}
else {
stop("first argument must be either factors or a table object")
}
}
#Convert supplied table style into full text string (e.g. "l" becomes "long")
style <- match.arg(style, c("long", "wide"))
#Extract row and col names to be used in creating 'tbl' from supplied input data
nms <- names(dimnames(tbl))
z <- length(nms)
if (!is.null(row.vars) && !is.numeric(row.vars)) {
row.vars <- order(match(nms, row.vars), na.last = NA)
}
if (!is.null(col.vars) && !is.numeric(col.vars)) {
col.vars <- order(match(nms, col.vars), na.last = NA)
}
if (!is.null(row.vars) && is.null(col.vars)) {
col.vars <- (1:z)[-row.vars]
}
if (!is.null(col.vars) && is.null(row.vars)) {
row.vars <- (1:z)[-col.vars]
}
if (is.null(row.vars) && is.null(col.vars)) {
col.vars <- z
row.vars <- (1:z)[-col.vars]
}
#Take the original input data, converted into table format using supplied row and col vars (tbl)
#and create a second version (Crosstab) which stores results as percentages if a percentage table type is requested.
if (type[1] == "frequency")
Crosstab <- tbl
else
Crosstab <- mk.pcnt.tbl(tbl, type[1])
#If multiple table types requested, create and add these to
if (length(type) > 1) {
tbldat <- as.data.frame.table(Crosstab)
z <- length(names(tbldat)) + 1
tbldat[z] <- 1
pcntlab <- type
pcntlab[match("frequency", type)] <- "Count"
pcntlab[match("row.pct", type)] <- "Row %"
pcntlab[match("column.pct", type)] <- "Column %"
pcntlab[match("joint.pct", type)] <- "Joint %"
pcntlab[match("total.pct", type)] <- "Total %"
for (i in 2:length(type)) {
if (type[i] == "frequency")
Crosstab <- tbl
else Crosstab <- mk.pcnt.tbl(tbl, type[i])
Crosstab <- as.data.frame.table(Crosstab)
Crosstab[z] <- i
tbldat <- rbind(tbldat, Crosstab)
}
tbldat[[z]] <- as.factor(tbldat[[z]])
levels(tbldat[[z]]) <- pcntlab
Crosstab <- xtabs(Freq ~ ., data = tbldat)
names(dimnames(Crosstab))[z - 1] <- ""
}
#Add margins if required, adding only those margins appropriate to user request
if (addmargins==TRUE) {
vars <- c(row.vars,col.vars)
if (length(type)==1) {
if (type=="row.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.vars]))
}
else
{ if (type=="column.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[n.row.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.row.vars]))
}
else
{ if (type=="joint.pct")
{ Crosstab <- addmargins(Crosstab,margin=c(vars[(n.row.vars)],vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[(n.row.vars)],vars[n.vars]))
}
else #must be total.pct OR frequency
{ Crosstab <- addmargins(Crosstab)
tbl <- addmargins(tbl)
}
}
}
}
#If more than one table type requested, only adding row totals makes any sense...
if (length(type)>1) {
Crosstab <- addmargins(Crosstab,margin=c(vars[n.vars]))
tbl <- addmargins(tbl,margin=c(vars[n.vars]))
}
}
#If subtotals not required, and total vars > 2, create dataframe version of table, with relevent
#subtotal rows / cols dropped [Subtotals only present in tables with > 2 cross-classified vars]
t1 <- NULL
if ( (subtotals==FALSE) & (n.vars>2) )  {
#Create version of Crosstab in ftable format
t1 <- Crosstab
t1 <- ftable(t1,row.vars=row.vars,col.vars=col.vars)
#Convert to a dataframe
t1 <- as.data.frame(format(t1),stringsAsFactors=FALSE)
#Remove backslashes from category names AND colnames
t1 <- apply(t1[,],2, function(x) gsub("\"","",x))
#Remove preceding and trailing spaces from category names to enable accurate capture of 'sum' rows/cols
#[Use of grep might extrac category labels with 'sum' as part of a longer one or two word string...]
t1 <- apply(t1,2,function(x) gsub("[[:space:]]*$","",gsub("^[[:space:]]*","",x)))
#Reshape dataframe to that variable and category labels display as required
#(a) Move col category names down one row; and move col variable name one column to right
t1[2,(n.row.vars+1):ncol(t1)] <- t1[1,(n.row.vars+1):ncol(t1)]
t1[1,] <- ""
t1[1,(n.row.vars+2)] <- t1[2,(n.row.vars+1)]
#(b) Drop the now redundant column separating the row.var labels from the table data + col.var labels
t1 <- t1[,-(n.row.vars+1)]
#In 'lab', assign category labels for each variable to all rows (to allow identification of sub-totals)
lab <- t1[,1:n.row.vars]
for (c in 1:n.row.vars) {
for (r in 2:nrow(lab)) {
if (lab[r,c]=="") lab[r,c] <- lab[r-1,c]
}
}
lab <- (apply(lab[,1:n.row.vars],2,function(x) x=="Sum"))
lab <- apply(lab,1,sum)
#Filter out rows of dataframe containing subtotals
t1 <- t1[((lab==0) | (lab==n.row.vars)),]
#Move the 'Sum' label associated with last row to the first column; in the process
#setting the final row labels associated with other row variables to ""
t1[nrow(t1),1] <- "Sum"
t1[nrow(t1),(2:n.row.vars)] <- ""
#set row and column names to NULL
rownames(t1) <- NULL
colnames(t1) <- NULL
}
#Create output object 'result' [class: Crosstab]
result <- NULL
#(a) record of argument values used to produce tabular output
result$row.vars <- row.vars
result$col.vars <- col.vars
result$dec.places <- dec.places
result$type <- type
result$style <- style
result$percentages <- percentages
result$addmargins <- addmargins
result$subtotals <- subtotals
#(b) tabular output [3 variants]
result$table <- tbl  #Stores original cross-tab frequency counts without margins [class: table]
result$Crosstab <- Crosstab #Stores cross-tab in table format using requested style(frequency/pct) and table margins (on/off)
#[class: table]
result$Crosstab.nosub <- t1  #Crosstab with subtotals suppressed [class: dataframe; or NULL if no subtotals suppressed]
class(result) <- "Crosstab"
#Return 'result' as output of function
result
}
print.Crosstab <- function(x,dec.places=x$dec.places,subtotals=x$subtotals,...) {
row.vars <- x$row.vars
col.vars <- x$col.vars
n.row.vars <- length(row.vars)
n.col.vars <- length(col.vars)
n.vars <- n.row.vars + n.col.vars
if (length(x$type)>1) {
z<-length(names(dimnames(x$Crosstab)))
if (x$style=="long") {
row.vars<-c(row.vars,z)
} else {
col.vars<-c(z,col.vars)
}
}
if (n.vars==1) {
if (length(x$type)==1) {
tmp <- data.frame(round(x$Crosstab,x$dec.places))
colnames(tmp)[2] <- ifelse(x$type=="frequency","Count","%")
print(tmp,row.names=FALSE)
} else {
print(round(x$Crosstab,x$dec.places))
}
}
#If table has only 2 dimensions, or subtotals required for >2 dimensional table,
#print table using ftable() on x$Crosstab
if ((n.vars == 2) | ((subtotals==TRUE) & (n.vars>2))) {
tbl <- ftable(x$Crosstab,row.vars=row.vars,col.vars=col.vars)
if (!all(as.integer(tbl)==as.numeric(tbl))) tbl <- round(tbl,dec.places)
print(tbl,...)
}
#If subtotals NOT required AND > 2 dimensions, print table using write.table() on x$Crosstab.nosub
if ((subtotals==FALSE) & (n.vars>2))  {
t1 <- x$Crosstab.nosub
#Convert numbers to required decimal places, right aligned
width <- max( nchar(t1[1,]), nchar(t1[2,]), 7 )
dec.places <- x$dec.places
number.format <- paste("%",width,".",dec.places,"f",sep="")
t1[3:nrow(t1),((n.row.vars+1):ncol(t1))] <- sprintf(number.format,as.numeric(t1[3:nrow(t1),((n.row.vars+1):ncol(t1))]))
#Adjust column variable label to same width as numbers, left aligned, padding with trailing spaces as required
col.var.format <- paste("%-",width,"s",sep="")
t1[1,(n.row.vars+1):ncol(t1)] <- sprintf(col.var.format,t1[1,(n.row.vars+1):ncol(t1)])
#Adjust column category labels to same width as numbers, right aligned, padding with preceding spaces as required
col.cat.format <- paste("%",width,"s",sep="")
t1[2,(n.row.vars+1):ncol(t1)] <- sprintf(col.cat.format,t1[2,(n.row.vars+1):ncol(t1)])
#Adjust row labels so that each column is of fixed width, using trailing spaces as required
for (i in 1:n.row.vars) {
width <- max(nchar(t1[,i])) + 2
row.lab.format <- paste("%-",width,"s",sep="")
t1[,i] <- sprintf(row.lab.format,t1[,i])
}
write.table(t1,quote=FALSE,col.names=FALSE,row.names=FALSE)
}
}
##### Data #####
## 2.1 Survey "Beliefs climate policies"
decrit(s$sexe)
##### Data #####
## 2.1 Survey "Beliefs climate policies"
decrit(s$sexe, weights = s$weight)
decrit(s$age)
decrit(s$csp)
decrit(s$diplome4)
decrit(s$taille_agglo)
decrit(s$region)
# Table II: Proportion of respondents per target of the payment
decrit(s$cible)
# Table II: Proportion of respondents per target of the payment
decrit(s$cible, weights = s$weight)
# Table II: Proportion of respondents per target of the payment
decrit(s$Cible)
# Table II: Proportion of respondents per target of the payment
decrit(n(s$cible))
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(sa$duree < 7*60, weights = sa$weight)
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(sa$duree < 7*60)
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(s$duree < 7*60, weights = s$weight) # 4%
# 2.1.3 Response time uncorrelated with preferences:
wtd.mean(s$duree < 9*60, weights = s$weight) # 4%
# Response time uncorrelated with preferences:
summary(lm(taxe_approbation!='Non' ~ duree, data=s, weights = s$weight))
summary(lm(gagnant_categorie!='Perdant' ~ duree, data=s, weights = s$weight))
summary(lm(gain ~ duree, data=s, weights = s$weight))
summary(lm(taxe_approbation!='Non' ~ duree + I(duree^2), data=s, weights = s$weight)) # .
summary(lm(gagnant_categorie!='Perdant' ~ duree + I(duree^2), data=s, weights = s$weight))
summary(lm(gain ~ duree + I(duree^2), data=s, weights = s$weight))
summary(lm(taxe_approbation!='Non' ~ duree + I(duree^2), data=s, weights = s$weight)) # .
# Bad quality screened out
wtd.mean(sa$test_qualite!='Un peu', weights = sa$weight)
# 2.1.3 Ensuring Data Quality
# Speeder screened out
wtd.mean(sa$duree < 7*60, weights = sa$weight) # 4% in original sample
wtd.mean(s$duree < 7*60, weights = s$weight) # 4%
##### Data #####
## 2.1 Survey "Beliefs climate policies"
# 2.1.1 Table I: Sample Characteristics
decrit(s$sexe)
# Bad quality screened out
wtd.mean(sa$test_qualite!='Un peu', weights = sa$weight)
wtd.mean(s$test_qualite!='Un peu', weights = s$weight) # 0 in final sample
sum(s$taille_menage > 12)
sum(n(s$revenu) > n(s$rev_tot) | n(s$revenu) > 10000 | n(s$rev_tot) > 10000)
sum(n(s$revenu) > n(s$rev_tot) | s$taille_menage < s$nb_adultes | s$taille_menage < s$nb_14_et_plus | n(s$revenu) > 10000 | n(s$rev_tot) > 10000)
sum(s$mauvaise_qualite>0)
decrit(s$mauvaise_qualite) # 250
decrit(s$mauvaise_qualite > 0) # 250
# mauvaise_qualite uncorrelated with preferences
summary(lm(taxe_approbation!='Non' ~ mauvaise_qualite, data=s, weights = s$weight))
summary(lm(gagnant_categorie!='Perdant' ~ mauvaise_qualite, data=s, weights = s$weight))
summary(lm(gain ~ mauvaise_qualite, data=s, weights = s$weight))
s$taille_menage[s$taille_menage > 12] # looks like zipcode
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 - s$hausse_carburants, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 * pmax(2, s$nb_adultes) - s$hausse_carburants, weights = s$weight)
decrit(s$gain, weights = s$weight)
decrit(50 * pmax(2, s$nb_adultes) - s$hausse_chauffage, weights = s$weight)
decrit(110 * pmax(2, s$nb_adultes) - s$hausse_depenses, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(60 * pmin(2, s$nb_adultes) - s$hausse_carburants, weights = s$weight)
decrit(50 * pmin(2, s$nb_adultes) - s$hausse_chauffage, weights = s$weight)
decrit(110 * pmin(2, s$nb_adultes) - s$hausse_depenses, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage, weights = s$weight)
decrit(s$gain, weights = s$weight)
ggplot(data=s, aes(x=60 * pmin(2, nb_adultes) - hausse_carburants)) + geom_density() + xlim(c(-100, 200))
fit_housing$vrai_gain_chauffage <- 50 * pmin(2, fit_housing$nb_adultes) - fit_housing$obj
fit_housing$estimation_gain_chauffage <- 50 * pmin(2, fit_housing$nb_adultes) - fit_housing$fit
ggplot(data=fit_housing, aes(x=vrai_gain_chauffage)) +
geom_smooth(method = "auto", aes(y=1*(estimation_gain_chauffage > 0))) + ylim(c(0,1)) + xlab("Objective gain without fuel (density in black)") + ylab("P(gain - (hausse_carburants-60) > 0) i.e. proba gain") + xlim(c(-200, 120)) + geom_density(aes(y=..scaled..)) + geom_vline(xintercept=0, col='red')
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage)
decrit(s$gain, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel, weights = s$weight)
decrit(s$gain_chauffage, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_min, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_max, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
decrit(s$gain_fuel_max)
decrit(s$gain > s$simule_gain, weights = s$weight)
##### 3 Perceptions #####
## 3.1 Impact on purchasing power
# Over-estimation of policy costs TODO: correct figures in paper
decrit(s$gain_fuel, weights = s$weight) # mean
decrit(s$gagnant_categorie, weights = s$weight)
decrit(s$gagnant_fuel_categorie, weights = s$weight) # 14% think they win (22% unaffected)
decrit(s$gagnant_chauffage_categorie, weights = s$weight) # 14% think they win (22% unaffected)
233.9086/1505.329
## 3.2 Robustness to assumptions on elasticities
decrit(s$Elasticite_fuel, weights = s$weight) # -0.43 perceived elasticity of French people
decrit(s$Elasticite_fuel_perso, weights = s$weight * s$depense_carburants) #
decrit(s$Elasticite_chauffage_perso, weights = s$weight * s$depense_chauffage) #
# 71% (resp. 80%) think they are strictly more contrained than average for fuel (resp. chauffage)
wtd.(s$Elasticite_fuel_perso > s$Elasticite_fuel, weights=s$weight, na.rm = T)
# 71% (resp. 80%) think they are strictly more contrained than average for fuel (resp. chauffage)
wtd.mean(s$Elasticite_fuel_perso > s$Elasticite_fuel, weights=s$weight, na.rm = T)
wtd.mean(s$Elasticite_chauffage_perso > s$Elasticite_chauffage, weights=s$weight, na.rm = T) # 80%
mar_old <- par()$mar
cex_old <- par()$cex
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
plot(density(objective_gains$transport, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$transport, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# (b) housing
plot(density(objective_gains$housing, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$housing, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# (c) both combined
plot(density(objective_gains$all, bw=30), xlim=c(-400, 200), lwd=2, col="blue", xlab="", main="") + grid()
lines(density(subjective_gains$all, bw=30), xlim=c(-400, 200), lwd=2, col="red")
# Figure 2: CDF of subjective vs. objective gain (including in the inelastic case)
par(mar = c(2.1, 4.1, 1.1, 0.1), cex=1.5)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport <- Ecdf(objective_gains$transport)
cdf_transport_inelastic <- Ecdf(objective_gains_inelastic$transport)
plot(Ecdf(s$gain_fuel), type="s", lwd=2, col="red", xlab="", main="", ylab=expression("Proportion "<=" x")) + grid()
lines(cdf_transport$x, cdf_transport$y, lwd=2, col="blue")
lines(cdf_transport_inelastic$x, cdf_transport_inelastic$y, lwd=2, lty=2, col="blue")
abline(v = c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), lty=3, col=rgb(1,0,0,0.7))
axis(3, at=c(-190, -110, -70, -40, -15, 0, 10, 20, 30, 40), tck=0.0, lwd=0, lwd.ticks = 0, padj=1.5, col.axis="red", cex.axis=0.9)
objective_gains <- read.csv2("df_objective_gains.csv")
subjective_gains <- read.csv2("df_subjective_gains.csv")
objective_gains_inelastic <- read.csv2("df_objective_gains_inelastic.csv")
objective_gains$transport <- n(objective_gains$gain_net_numeric_uc_fuel)
objective_gains$housing <- n(objective_gains$gain_net_numeric_uc_chauffage)
objective_gains$all <- n(objective_gains$gain_net_numeric_uc_taxe_carbone)
subjective_gains$transport <- n(subjective_gains$subjective_gain_numeric_fuel)
subjective_gains$housing <- n(subjective_gains$subjective_gain_numeric_chauffage)
subjective_gains$all <- n(subjective_gains$subjective_gain_numeric_taxe_carbone)
objective_gains_inelastic$transport <- n(objective_gains_inelastic$gain_net_numeric_uc_fuel)
objective_gains_inelastic$housing <- n(objective_gains_inelastic$gain_net_numeric_uc_chauffage)
objective_gains_inelastic$all <- n(objective_gains_inelastic$gain_net_numeric_uc_taxe_carbone)
objective_gains_inelastic <- read.csv2("df_objective_gains_inelastic.csv")
objective_gains$transport <- n(objective_gains$gain_net_numeric_uc_fuel)
objective_gains$housing <- n(objective_gains$gain_net_numeric_uc_chauffage)
objective_gains$all <- n(objective_gains$gain_net_numeric_uc_taxe_carbone)
subjective_gains$transport <- n(subjective_gains$subjective_gain_numeric_fuel)
subjective_gains$housing <- n(subjective_gains$subjective_gain_numeric_chauffage)
subjective_gains$all <- n(subjective_gains$subjective_gain_numeric_taxe_carbone)
objective_gains_inelastic$transport <- n(objective_gains_inelastic$gain_net_numeric_uc_fuel)
objective_gains_inelastic$housing <- n(objective_gains_inelastic$gain_net_numeric_uc_chauffage)
objective_gains_inelastic$all <- n(objective_gains_inelastic$gain_net_numeric_uc_taxe_carbone)
decrit(subjective_gains$transport)
decrit(subjective_gains$housing)
decrit(subjective_gains$all)
decrit(s$fioul)
decrit(s$gaz)
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
decrit(ss$fioul)
decrit(ss$gaz)
decrit(s$fioul)
names(s)
names(ss)[!(names(ss) %in% names(s))]
which(!(names(ss) %in% names(s)))
write.csv(s, "survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv")
ss <- read.csv("survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv", row.names = 1)
ss <- read.csv("survey_prepared.csv")
ss <- read.csv("survey_prepared.csv", row.names = NULL)
ss <- read.csv("survey_prepared.csv", row.names = TRUE)
ss <- read.csv("survey_prepared.csv")
duplicated(s$id)
which(duplicated(s$id))
write.csv(s, "survey_prepared.csv", row.names = NULL)
write.csv(s, "survey_prepared.csv", row.names = FALSe)
ss <- read.csv("survey_prepared.csv", skip = 1
)
ss <- read.csv("survey_prepared.csv", header = FALSE)
ss <- read.csv("survey_prepared.csv", header = T)
which(duplicated(names(s)))
write.csv(s[-c(1294,1666),], "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
write.csv(s[-c(1294,1666),], "survey_prepared.csv", row.names = FALSE)
ss <- read.csv("survey_prepared.csv")
write.csv(s[-c(1294,1666),], "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
package("utils")
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
names(s)
names(ss)
names(ss)[!(names(ss) %in% names(s))]
names(ss)[!(names(s) %in% names(ss))]
head(ss$weight)
write.csv2(s, "survey_prepared.csv")
ss <- read.csv2("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
write.csv(s, "survey_prepared.csv", eol="\n\n")
ss <- read.csv("survey_prepared.csv", eol="\n\n")
ss <- read.csv("survey_prepared.csv",)
write.csv(s, "survey_prepared.csv")
ss <- read.csv("survey_prepared.csv")
make.names(names(s))
which(make.names(names(s))!=names(s))
ss <- read.csv("survey_prepared.csv", check.names=FALSE)
write.csv(s, "survey_prepared.csv", row.names=FALSE)
ss <- read.csv("survey_prepared.csv")
write.csv(s, "survey_prepared.csv")
write.csv(s, "survey_prepared.csv", row.names='n')
write.csv(s, "survey_prepared.csv", row.names=FALSE)
ss <- read.csv("survey_prepared.csv", row.names=NULL)
>>>>>>> Stashed changes
